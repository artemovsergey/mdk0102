# Лекция 5. Техники тест-дизайна для инженера по тестированию .NET

**Цель лекции:** Систематизировать знания о техниках тест-дизайна, показать их практическое применение в контексте разработки на .NET и научить выбирать подходящие техники для различных сценариев.

---

### **План лекции:**

1.  **Введение: Что такое тест-дизайн и зачем он нужен?**
2.  **Классификация техник тест-дизайна.**
3.  **Техники, основанные на спецификации (Specification-Based или Black-Box):**
    *   Эквивалентное Разделение (Equivalence Partitioning)
    *   Анализ Граничных Значений (Boundary Value Analysis)
    *   Таблицы Решений (Decision Tables)
    *   Диаграммы Переходов Состояний (State Transition Diagrams)
    *   Сценарии использования (Use Case Testing)
4.  **Техники, основанные на структуре (Structure-Based или White-Box):**
    *   Тестирование Потока Управления (Coverage: Statement, Branch, Condition)
5.  **Техники, основанные на опыте (Experience-Based):**
    *   Исследовательское тестирование (Exploratory Testing)
    * *Тестирование на основе предположений об ошибках (Error Guessing)*
6.  **Практическое применение в .NET: Инструменты и примеры.**
7.  **Резюме.**
8.  **Контрольные вопросы.**

---

### **1. Введение: Что такое тест-дизайн и зачем он нужен?**

**Тест-дизайн** — это этап процесса тестирования, на котором мы проектируем и создаем тестовые случаи (test cases) в соответствии с определенными заранее целями и критериями качества.

**Зачем это нужно?**
*   **Эффективность:** Позволяет найти больше дефектов, используя меньше тестов.
*   **Экономия времени и ресурсов:** Мы не тестируем все подряд, а концентрируемся на самых важных и рискованных областях.
*   **Воспроизводимость:** Хорошо спроектированные тесты можно легко запускать повторно (это основа автоматизации).
*   **Покрытие (Coverage):** Помогает достичь требуемого уровня покрытия кода или требований.

**Аналогия:** Представьте, что вам нужно проверить работу лифта. Можно просто кататься на нем целый день (это *неструктурированное* тестирование). А можно применить техники тест-дизайна:
*   *Эквивалентное Разделение:* Грузоподъемность 1000 кг. Проверим легкий вес (50 кг), нормальный (500 кг) и предельный (1000 кг).
*   *Анализ Граничных Значений:* Обязательно проверим 999 кг и 1001 кг.
*   *Таблица Решений:* Что будет, если нажать "Стоп" во время движения? Или попытаться открыть дверь между этажами?

---

### **2. Классификация техник тест-дизайна**

Техники делятся на три основные группы в зависимости от того, какую информацию мы используем для создания тестов:

1.  **Specification-Based (Black-Box):** Мы не смотрим на код. Мы проектируем тесты, основываясь на требованиях, спецификациях и функциональности системы. *"Что делает система?"*
2.  **Structure-Based (White-Box):** Мы заглядываем внутрь кода и используем его структуру для создания тестов. *"Как система это делает?"*
3.  **Experience-Based:** Мы полагаемся на наш опыт, интуицию и знания о системе, ее пользователях и типичных ошибках разработчиков.

---

### **3. Техники, основанные на спецификации (Black-Box)**

#### **3.1. Эквивалентное Разделение (Equivalence Partitioning - EP)**

**Идея:** Все возможные входные данные разбиваются на группы (классы эквивалентности), где данные внутри одной группы должны обрабатываться системой одинаково. Поэтому достаточно протестировать по одному значению из каждого класса.

**Пример для .NET:** Допустим, у нас есть метод в сервисе для проверки возраста пользователя `ValidateUserAge(int age)`. Требование: возраст должен быть от 18 до 65 лет включительно.

*   Мы можем выделить **три класса эквивалентности**:
    1.  **Невалидные (молодые):** `age < 18` (например, 10)
    2.  **Валидные:** `18 <= age <= 65` (например, 30)
    3.  **Невалидные (пожилые):** `age > 65` (например, 70)

Вместо тысяч возможных значений мы тестируем всего три.

#### **3.2. Анализ Граничных Значений (Boundary Value Analysis - BVA)**

**Идея:** Ошибки часто возникают на границах классов эквивалентности. Поэтому помимо значений из середины класса, мы обязательно тестируем значения на самих границах и сразу за ними.

**Правило:** Для диапазона `[a, b]` тестируем: `a-1`, `a`, `a+1`, `b-1`, `b`, `b+1`.

**Пример (продолжаем с возрастом):** Диапазон `[18, 65]`.

*   **Граничные значения для тестирования:**
    *   `17` (нижняя граница - 1) -> Ожидается ошибка.
    *   `18` (нижняя граница) -> Ожидается успех.
    *   `19` (нижняя граница + 1) -> Ожидается успех.
    *   `64` (верхняя граница - 1) -> Ожидается успех.
    *   `65` (верхняя граница) -> Ожидается успех.
    *   `66` (верхняя граница + 1) -> Ожидается ошибка.

**Практика в .NET:**
```csharp
[Test]
public void ValidateUserAge_AgeIs17_ReturnsFalse()
{
    // Arrange
    var userService = new UserService();

    // Act
    bool result = userService.ValidateUserAge(17);

    // Assert
    Assert.IsFalse(result);
}

[Test]
public void ValidateUserAge_AgeIs18_ReturnsTrue()
{
    // Arrange
    var userService = new UserService();

    // Act
    bool result = userService.ValidateUserAge(18);

    // Assert
    Assert.IsTrue(result);
}
// ... и так далее для других граничных значений
```

#### **3.3. Таблицы Решений (Decision Tables)**

**Идея:** Используется для тестирования бизнес-логики, на которую влияет комбинация условий. Представляет собой таблицу, где перечислены все условия и все возможные действия.

**Пример:** Логика одобрения кредита в банковском приложении .NET.
**Условия:**
1.  Хорошая кредитная история (True/False)
2.  Высокий доход (True/False)
3.  Большой первоначальный взнос (True/False)

| № | Кред. история | Доход | Взнос | **Действие (Решение)** |
|---|---------------|-------|-------|------------------------|
| 1 | True          | True  | True  | **Одобрить**           |
| 2 | True          | True  | False | **Одобрить**           |
| 3 | True          | False | True  | **Одобрить**           |
| 4 | True          | False | False | **Отклонить**          |
| 5 | False         | True  | True  | **Одобрить с повышенной ставкой** |
| 6 | False         | True  | False | **Отклонить**          |
| 7 | False         | False | True  | **Отклонить**          |
| 8 | False         | False | False | **Отклонить**          |

Каждая строка этой таблицы — это готовый тестовый сценарий.

#### **3.4. Диаграммы Переходов Состояний (State Transition Diagrams)**

**Идея:** Используется для систем, которые могут находиться в разных состояниях, и переход между этими состояниями зависит от событий или условий.

**Пример:** Тестирование объекта `Order` в интернет-магазине.
*   **Состояния:** `New`, `Paid`, `Shipped`, `Delivered`, `Cancelled`.
*   **События:** `Pay()`, `Ship()`, `ConfirmDelivery()`, `Cancel()`.

```
[New] --Pay()--> [Paid] --Ship()--> [Shipped] --ConfirmDelivery()--> [Delivered]
     |                                             ^
      --Cancel()--> [Cancelled]                    |
                                                    ---Cancel()--> [Ошибка!]
```
Мы тестируем валидные переходы (например, `New -> Paid -> Shipped -> Delivered`) и невалидные (например, попытка отменить доставленный заказ `Delivered -> Cancel()` должна вызывать исключение).

**Код на C#:**
```csharp
[Test]
public void CancelOrder_FromShippedState_ThrowsException()
{
    // Arrange
    var order = new Order();
    order.Pay(); // Переводим в Paid
    order.Ship(); // Переводим в Shipped

    // Act & Assert
    Assert.Throws<InvalidOperationException>(() => order.Cancel());
}
```

#### **3.5. Сценарии использования (Use Case Testing)**

**Идея:** Тесты проектируются на основе сценариев использования (Use Case), которые описывают, как пользователь взаимодействует с системой для достижения конкретной цели. Это очень полезно для интеграционного и системного тестирования.

**Пример:** Use Case "Оформление заказа".
1.  **Основной поток:** Пользователь добавляет товар в корзину -> переходит к оплате -> вводит валидные данные карты -> подтверждает заказ -> получает номер заказа.
2.  **Альтернативный поток A:** На этапе оплаты данные карты неверны. Система показывает ошибку, пользователь может попробовать снова.
3.  **Альтернативный поток B:** Пользователь удаляет товар из корзины до оплаты.

Каждый поток — это готовый тест-сьют.

---

### **4. Техники, основанные на структуре (White-Box)**

#### **4.1. Тестирование Потока Управления**

**Идея:** Мы анализируем исходный код и измеряем **покрытие (coverage)**, чтобы понять, какие части кода были выполнены во время тестов.

*   **Покрытие операторов (Statement Coverage):** Каждая ли строка кода была выполнена хотя бы раз?
*   **Покрытие ветвей (Branch Coverage):** Каждая ли ветка операторов `if`, `else`, `switch`, `while` была выполнена и в `true`, и в `false` варианте?
*   **Покрытие условий (Condition Coverage):** Каждое ли элементарное логическое условие внутри сложного выражения было и `true`, и `false`?

**Пример в .NET:**
```csharp
public string CalculateDiscount(bool isPremiumUser, int orderAmount)
{
    if (isPremiumUser && orderAmount > 1000) // Условие 1 и Условие 2
    {
        return "DISCOUNT_20"; // Ветка A
    }
    else
    {
        return "DISCOUNT_5";  // Ветка B
    }
}
```
*   **Statement Coverage:** Нам нужен один тест, который пройдет по всем строкам. `(isPremiumUser=true, orderAmount=1500)` выполнит обе строки с `return`.
*   **Branch Coverage:** Нам нужно покрыть обе ветки `if` и `else`.
    *   Тест 1: `(true, 1500)` -> Ветка A.
    *   Тест 2: `(false, 500)` -> Ветка B.
*   **Condition Coverage:** Нам нужно, чтобы и `isPremiumUser`, и `orderAmount > 1000` были и true, и false.
    *   Тест 1: `(true, 1500)` -> `isPremiumUser=true`, `orderAmount>1000=true`.
    *   Тест 2: `(false, 500)` -> `isPremiumUser=false`, `orderAmount>1000=false`.

**Инструменты в .NET:** JetBrains dotCover, Visual Studio Enterprise Code Coverage, Coverlet.

---

### **5. Техники, основанные на опыте (Experience-Based)**

#### **5.1. Исследовательское тестирование (Exploratory Testing)**

**Идея:** Процесс одновременного изучения системы, проектирования тестов и их выполнения. Нет заранее написанных тест-кейсов. Тестировщик использует свои знания, креативность и логику для поиска дефектов.

**Как применять в .NET:**
*   **Сессии:** Выделяется ограниченное по времени "окно" (например, 90 минут) на исследование определенного модуля (например, "Форма импорта данных").
*   **Цель:** Найти как можно больше дефектов или проблем с удобством использования.
*   **Пример:** Тестируя веб-API на ASP.NET Core, можно с помощью Postman или Swagger пробовать отправлять некорректные JSON-ы, менять типы данных в полях, проверять реакцию на SQL-инъекции в строковых параметрах.

#### **5.2. Тестирование на основе предположений об ошибках (Error Guessing)**

**Идея:** Тестировщик использует свой опыт, чтобы предположить, в каких местах системы с наибольшей вероятностью могут быть ошибки.

**Типичные "догадки" для .NET-разработки:**
*   **Деление на ноль:** `int result = a / b;` где `b` может быть 0.
*   **Обработка `null`:** Передача `null` в аргументы методов, чтение свойств у `null`-объекта (`NullReferenceException`).
*   **Ошибки при работе с БД:** Не закрытые соединения (`SqlConnection`), дедлоки.
*   **Проблемы с культурами (Cultures):** Преобразование строк в числа и даты, если сервер работает в одной культуре, а клиент в другой.
*   **Утечки памяти:** Особенно при работе с событиями (неотписанные обработчики событий) или неуправляемыми ресурсами.

---

### **6. Практическое применение в .NET: Инструменты и примеры**

*   **xUnit/NUnit/MSTest:** Фреймворки для модульного и интеграционного тестирования. Позволяют структурировать тесты, созданные с помощью описанных выше техник.
*   **FluentAssertions:** Библиотека для более читаемых утверждений (Assert).
    ```csharp
    // Вместо Assert.AreEqual(expected, actual);
    result.Should().BeTrue();
    order.Status.Should().Be(OrderStatus.Paid);
    ```
*   **Moq / NSubstitute:** Библиотеки для создания mock-объектов. Позволяют изолировать тестируемый код.
    ```csharp
    // Тестируем сервис, который зависит от репозитория
    var mockRepo = new Mock<IUserRepository>();
    mockRepo.Setup(repo => repo.GetUser(It.IsAny<int>())).Returns((User)null); // Эмулируем ситуацию, когда пользователь не найден

    var userService = new UserService(mockRepo.Object);
    var result = userService.FindUser(999); // User с ID 999 не существует

    result.Should().BeNull();
    ```
*   **Coverlet / dotCover:** Для измерения покрытия кода.
*   **Postman / Swagger:** Для исследовательского тестирования API.

---

### **7. Резюме**

*   **Тест-дизайн — это не случайность, а дисциплина.** Он позволяет быть эффективным и систематичным.
*   **Используйте комбинацию техник.** Не существует одной "самой лучшей" техники.
    *   Начните с **Black-Box** техник (EP, BVA) для покрытия базовой функциональности.
    *   Для сложной бизнес-логики применяйте **Таблицы Решений** и **Диаграммы Переходов**.
    *   Используйте **White-Box** техники для достижения высокого покрытия кода и поиска "спрятанных" багов в редко выполняемых ветках.
    *   Всегда дополняйте формальные техники **Исследовательским тестированием** и **Error Guessing**.
*   **В контексте .NET** у вас есть мощный инструментарий (xUnit, Moq, FluentAssertions) для реализации любых техник тест-дизайна в виде автоматизированных тестов.

**Ключевой вывод:** Хороший инженер по тестированию знает, КОГДА и КАКУЮ технику применить для максимально быстрого и точного нахождения дефектов.

---

### **8. Контрольные вопросы**

1.  В чем основное различие между техниками Black-Box и White-Box? Приведите по одному примеру каждой.
2.  У вас есть поле для ввода пароля, которое должно содержать от 6 до 12 символов. Примените технику Эквивалентного Разделения и Анализа Граничных Значений. Какие конкретно тестовые данные вы бы ввели?
3.  Объясните, в какой ситуации для тестирования лучше всего подойдет Таблица Решений, а в какой — Диаграмма Переходов Состояний.
4.  Что такое "Покрытие ветвей" (Branch Coverage)? Чем оно отличается от "Покрытия операторов" (Statement Coverage)? Проиллюстрируйте на простом примере кода на C#.
5.  Вы тестируете метод, который сохраняет файл на диск. Какие предположения об ошибках (Error Guessing) вы можете сделать, исходя из своего опыта?
6.  Как бы вы сочетали исследовательское тестирование и формальные техники тест-дизайна при тестировании нового веб-API, написанного на ASP.NET Core?