# Лекция 1. Краткая история и основные принципы тестирования ПО

## Цель лекции

Дать студентам системное представление о том, как развивалось тестирование ПО, какие существуют ключевые принципы, уровни и техники тестирования, как всё это применяется на практике (включая примеры и сниппеты на .NET), а также обеспечить контроль усвоения материала.

---

## План лекции

1. Введение: зачем нужно тестирование (цели, ценность)
2. Краткая история тестирования ПО (вехи развития)
3. Основные принципы тестирования (и правила Майлза/Канера/Баса)
4. Уровни тестирования: unit, integration, system, acceptance — подробности и примеры
5. Типы тестирования: функциональное и нефункциональное (regression, smoke, performance, security и т.д.)
6. Техники проектирования тестов (equivalence, BVA, decision tables, state transition, pairwise) — с примерами
7. Артефакты тестирования: тест-план, тест-кейсы, чек-листы, баг-репорты, тестовые данные, окружения
8. Автоматизация тестирования в .NET: инструменты, архитектуры, примеры кода
9. Метрики и показатели качества тестирования (coverage, pass rate, MTTR, defect density)
10. Интеграция QA в процесс разработки: Agile/TDD/CI-CD, практики «shift-left»
11. Частые ошибки и антипаттерны в тестировании + лучшие практики
12. Резюме
13. Контрольные вопросы

---

# 1. Введение: зачем нужно тестирование

**Основные цели:**

* Найти дефекты до выпуска (минимизация рисков для бизнеса).
* Проверить соответствие продукта требованиям (валидность).
* Обеспечить качество в долгосрочной перспективе (поддерживаемость, надежность).
* Обеспечить доверие пользователей и стейкхолдеров.

**Примеры ценности:**

* Ошибка расчёта процентов в банковском ПО → финансовые потери → тестирование предотвращает.
* Нагрузка на сайт при распродаже → тест производительности до релиза предотвращает падение сервиса.

---

# 2. Краткая история тестирования ПО (вехи)

1. **1950–60-е — ранние вычисления:** тестирование ad-hoc: запуск и визуальная проверка результатов.
   *Пример:* программа для расчёта траекторий — запускают с «эталонными» значениями и сравнивают вручную.

2. **1970-е — формализация:** появление Waterfall, понятия верификации и валидации. Тестирование — отдельная фаза.
   *Пример:* тестовая фаза после интеграции всех модулей.

3. **1980–90-е — модель V, тестовые уровни:** более явное разделение unit/integration/system/acceptance. Появление автоматизации на уровне unit (xUnit-семейство в зародыше).
   *Пример:* тесты модулей запускаются отдельно от системного тестирования.

4. **2000-е — Agile и CI/CD:** тестирование «сдвигается влево», TDD набирает популярность, автоматизация становится обязательной.
   *Пример:* pipeline, запускающий unit и integration тесты при каждом коммите.

5. **2010-е — DevOps, тестирование производительности, безопасность:** тестирование рассматривается как непрерывный процесс. Появляются такие инструменты, как Selenium, Appium, Playwright, SpecFlow.
   *Пример:* nightly performance-тесты, автоматизированные UI-тесты в pipeline.

6. **2020-е — масштабирование автотестов, наблюдаемость, SRE/QA-интеграция:** тестирование в продакшне, shift-right практики (канареечные релизы, feature flags), тестирование данных/ML.
   *Пример:* A/B-тесты и мониторинг ошибок в реальном времени.

---

# 3. Основные принципы тестирования (с объяснениями и примерами)

1. **Тестирование показывает присутствие дефектов, а не их отсутствие.**
   *Пример:* пройденные тесты не гарантируют отсутствие ошибок в коде, они лишь повышают уверенность.

2. **Исчерпывающее тестирование невозможно (практически).**
   *Пример:* для функции, принимающей 10 чисел, полный перебор комбинаций нереален.

3. **Раннее тестирование (Shift-Left).**
   *Пример:* писать unit-тесты при разработке модуля, проводить код-ревью тестов.

4. **Парадигма «риск-ориентированного тестирования».**
   Фокус тестирования на тех областях, где последствия дефекта критичны.
   *Пример:* для платёжного сервиса больше тестов на транзакции, меньше — на UI-цвета.

5. **Пестицидный парадокс (Pesticide Paradox).**
   Если запускать одни и те же тесты снова и снова, они перестают находить новые дефекты — тесты нужно обновлять.
   *Пример:* добавить новые тесты на границы и сценарии, которые ранее не проверялись.

6. **Дефект кластеризуется (80/20 правило).**
   Небольшая часть модулей содержит большинство дефектов.
   *Пример:* в крупном приложении 20% кода — 80% багов → фокус тестирования.

7. **Контекст-зависимость (Context-driven testing).**
   Нет «одного правильного способа» тестирования — нужно подбирать практики к проекту.
   *Пример:* для медицинского ПО больше формальности и валидации, для стартапа — быстрая итерация и автоматизация.

---

# 4. Уровни тестирования — подробно + примеры

### 4.1 Unit-тесты

**Что проверяют:** отдельные функции/методы класса.
**Кто выполняет:** разработчик (часто) или автоматизированная CI-система.
**Примеры в .NET (xUnit):**

```csharp
public class Calculator {
    public int Add(int a, int b) => a + b;
}

public class CalculatorTests {
    [Fact]
    public void Add_ReturnsSum() {
        var calc = new Calculator();
        Assert.Equal(5, calc.Add(2, 3));
    }
}
```

**Типичные кейсы:** позитивные и негативные сценарии, граничные значения, исключения.

### 4.2 Integration-тесты

**Что проверяют:** взаимодействие между компонентами (например, сервис ↔ БД).
**Примеры:** тест сервиса, который сохраняет заказ в базу и вызывает внешнюю платежную систему (можно мокать внешние вызовы).
**Техника:** использовать in-memory DB (например, SQLite in-memory) или тестовую БД.

### 4.3 System / End-to-End (E2E)

**Что проверяют:** система целиком — UI → backend → DB.
**Примеры:** Selenium/Playwright тесты, которые логинятся, создают запись и проверяют её отображение.

### 4.4 Acceptance / UAT

**Что проверяют:** соотвествие требованиям заказчика или бизнес-критериям.
**Примеры:** набор сценариев по user story, часто выполняются вручную бизнес-пользователями или с помощью BDD (SpecFlow).

---

# 5. Типы тестирования (с примерами)

### 5.1 Функциональное тестирование

Проверка функционала согласно требованиям.
*Пример:* при нажатии кнопки «Оплатить» транзакция должна пройти.

### 5.2 Регрессионное тестирование

Проверка, что изменения не нарушили старую функциональность.
*Пример:* после рефакторинга модуля авторизации запускается regression pack.

### 5.3 Smoke / Sanity тестирование

Быстрая проверка основных функций перед глубокой проверкой.
*Пример:* при деплое проверить, что приложение стартует и доступен логин.

### 5.4 Нефункциональное тестирование

* **Производительность (load/stress):** JMeter, k6.
  *Пример:* 10k пользователей одновременно на страницу каталога.
* **Безопасность (security):** OWASP ZAP, сканирование уязвимостей.
  *Пример:* SQL-инъекции, XSS.
* **Юзабилити, доступность (a11y)**: тесты по WCAG.
* **Совместимость (compatibility):** разные браузеры, устройства.

### 5.5 Exploratory testing

Исследовательское тестирование без заранее написанных кейсов — специалист исследует продукт.
*Пример:* QA проводит сессию 90 минут, пытаясь «сломать» форму ввода.

---

# 6. Техники проектирования тестов — детально с примерами

### 6.1 Эквивалентное разбиение (Equivalence Partitioning)

Разбиваем входные значения на классы эквивалентности. Тестируем по одному представителю из каждого класса.
*Пример:* поле «возраст» 0–17 (child), 18–64 (adult), 65+ (senior) — тестируем 5, 30, 70.

### 6.2 Граничные значения (Boundary Value Analysis)

Тестируем границы диапазонов (обычные ошибки проявляются там).
*Пример:* поле, принимающее 1..100 → проверяем 0,1,2,99,100,101.

### 6.3 Decision Tables (таблицы решений)

Удобно, когда есть множество комбинаций входов → перечисляем правила и ожидаемые результаты.
*Пример:* скидка: если VIP и сумма>1000 → 10%, если не VIP и сумма>2000 → 5%, и т.д.

### 6.4 State Transition Testing

Когда поведение зависит от состояний и переходов.
*Пример:* статус заказа: New → Paid → Shipped → Delivered; протестировать переходы и недопустимые переходы.

### 6.5 Pairwise (комбинационное тестирование)

Для большого числа переменных берём все парные комбинации, чтобы сократить набор тестов, сохраняя покрытие сочетаний.
*Пример:* браузер × ОС × роль пользователя — pairwise даст минимальный набор.

---

# 7. Артефакты тестирования — что писать и как

### Тест-план

* Область тестирования, ресурсы, расписание, критерии входа/выхода, риски.
  *Пример:* «Regression pack запускается при каждом PR».

### Тест-кейсы

* Шаги, ожидание, предусловия, постусловия, тестовые данные.
  *Пример структуры:* ID, Title, Precondition, Steps, Expected Result, Actual Result, Status, Notes.

### Чек-листы

* Короткие списки проверки (быстрые проверки).
  *Пример:* проверка UI релиза: логин, создание записи, логирование, ссылки 404.

### Баг-репорт

* Минимум: summary, steps to reproduce, expected vs actual, severity, priority, environment, logs/screenshots.
  *Пример:* "Login fails with 500 when username contains '+' — Steps: ... — Expected: success — Actual: 500 — Attach logs."

### Тестовые данные и окружение

* Фиксированные и генерация данных, секреты, настройка тестовой БД, sandbox внешних сервисов (mocks/stubs).

---

# 8. Автоматизация тестирования в .NET — инструменты и архитектуры

### Инструменты

* **Unit testing:** xUnit, NUnit, MSTest.
* **Mocking:** Moq, NSubstitute.
* **Integration / E2E:** Selenium, Playwright, Puppeteer (через Playwright .NET).
* **BDD:** SpecFlow (Gherkin).
* **CI/CD:** Azure DevOps, GitHub Actions, TeamCity, Jenkins.
* **API testing:** REST-assured (Java) / HttpClient + FluentAssertions (.NET), Postman/Newman.
* **Performance:** k6, Artillery, JMeter (интеграция через CI).
* **Code coverage:** Coverlet, ReportGenerator.
* **Contract testing:** Pact.

### Архитектура тестовой автоматизации

* Разделение: unit tests (быстрые) → integration tests (медленнее) → e2e (дорогостоящие).
* Тесты в pipeline имеют тэги: fast, slow, nightly.
* Использовать Page Object Pattern для UI-тестов (поддерживаемость).

### Примеры кода

**Unit test (xUnit + Moq):**

```csharp
public interface IEmailService {
    void Send(string to, string subject, string body);
}

public class UserService {
    private readonly IEmailService _email;
    public UserService(IEmailService email) { _email = email; }
    public void Register(string email) {
        // ... регистрация
        _email.Send(email, "Welcome", "...");
    }
}

public class UserServiceTests {
    [Fact]
    public void Register_SendsWelcomeEmail() {
        var mockEmail = new Mock<IEmailService>();
        var svc = new UserService(mockEmail.Object);

        svc.Register("test@example.com");

        mockEmail.Verify(e => e.Send("test@example.com", "Welcome", It.IsAny<string>()), Times.Once);
    }
}
```

**Пример простого Selenium (C#) E2E:**

```csharp
using OpenQA.Selenium;
using OpenQA.Selenium.Chrome;

var driver = new ChromeDriver();
driver.Navigate().GoToUrl("https://example.com/login");
driver.FindElement(By.Id("username")).SendKeys("user");
driver.FindElement(By.Id("password")).SendKeys("pass");
driver.FindElement(By.Id("submit")).Click();
var welcome = driver.FindElement(By.Id("welcome")).Text;
Assert.Equal("Welcome, user!", welcome);
driver.Quit();
```

**BDD (SpecFlow) — пример сценария Gherkin:**

```gherkin
Feature: User registration
  Scenario: Successful registration
    Given I open the registration page
    When I submit valid user data
    Then I should see confirmation message
```

### Практические советы по автоматизации

* Unit тесты не должны обращаться к сети/DB (используйте моки).
* Integration tests — использовать тестовую/изоляционную DB.
* E2E тесты — более хрупкие, держать их в минимуме и покрывать критичные пути.
* Параллелизация тестов — экономит время, но следите за изоляцией (shared state).
* CI pipeline: запускать unit tests на PR, integration при merge, nightly для heavy-pack.

---

# 9. Метрики и показатели качества тестирования

* **Coverage (покрытие кода):** % покрытых строк/ветвлений (не цель сам по себе).
  *Пример:* 85% coverage — хорошая цель, но важна релевантность тестов.
* **Pass rate:** % прошедших тестов из общего набора.
* **Defect density:** баги на KLOC.
* **MTTR (Mean Time To Repair):** среднее время на исправление дефекта.
* **Escaped defects:** дефекты, найденные в проде (они должны минимизироваться).
* **Automation ROI:** сколько времени/ресурсов экономит автоматизация.

**Примечание:** Не полагайтесь на метрики в отрыве — смотрите тренды и причины.

---

# 10. Интеграция QA в SDLC: Agile, TDD, CI/CD

* **TDD (Test Driven Development):** писать тест сначала, затем код. Хорошо для unit/логики.
  *Пример цикла:* Red → Green → Refactor.

* **CI/CD:** автоматический запуск тестов при коммите → билд → деплой.
  *Пример:* GitHub Actions workflow, запускающий `dotnet test` + сборку отчетов coverage.

* **Shift-Left:** привлечение QA на ранних стадиях (хотя бы для ревью требований, acceptance criteria).

* **Shift-Right:** мониторинг и тесты в продакшене (canary, feature flags).

* **Collaborative testing:** developers + testers + PO работают вместе над критериями приёмки.

---

# 11. Частые ошибки и антипаттерны + лучшие практики

### Ошибки

* Автоматизируют всё подряд → поддержка тестов дороже, чем ручное выполнение.
* Полагаются только на UI-тесты. UI-тесты хрупкие и медленные.
* Отсутствие изоляции тестов (shared DB) → flaky tests.
* Нет тестовых данных/слабая подготовка окружения.
* Плохие баг-репорты (нет шагов, логов) → медленное исправление.

### Лучшие практики

* **Пирамида тестирования:** больше unit, меньше integration, ещё меньше E2E.
* **Держать тесты изолированными** и детерминированными.
* **Короткие, быстрые unit тесты** в каждом PR.
* **Регулярно рефакторить тесты** (борьба с pesticide paradox).
* **Хорошие баг-репорты** (логи, скриншоты, steps).
* **CI с «гигантской зелёной» индикацией**: не деплойте, если тесты падают.
* **Ввод мониторинга в проде** и автоматизированные rollback/alerts.

---

# 12. Резюме (кратко)

* Тестирование эволюционировало от ad-hoc проверок до непрерывной практики, интегрированной в SDLC.
* Принципы тестирования (раннее тестирование, риск-ориентированность, невозможность полного покрытия) — фундамент.
* Существуют уровни тестирования: unit, integration, system, acceptance — каждый решает свои задачи.
* Выбор техник проектирования тестов и типов тестирования зависит от контекста проекта.
* Автоматизация в .NET — мощный инструмент (xUnit, Moq, Playwright/ Selenium, SpecFlow), но требует дисциплины.
* Метрики помогают, но важны тренды и причины.
* QA — командная функция: лучше включать тестирование с самого начала.

---

# 13. Контрольные вопросы

1. Почему невозможно провести исчерпывающее тестирование программы? Приведите пример.
2. Назовите и кратко объясните три принципа тестирования.
3. Чем unit-тесты отличаются от интеграционных? Приведите пример, где нужен integration test.
4. Что такое пестицидный парадокс и как с ним бороться?
5. Опишите структуру хорошего баг-репорта. Какие поля обязателны?
6. Что такое TDD и как он влияет на дизайн кода?
7. Назовите три техники проектирования тестов и для каких задач они подходят.
8. Объясните, почему UI-тесты не должны быть единственным видом автоматизированных тестов.
9. Как выстроить CI-pipeline для .NET-проекта: какие категории тестов запускать на PR, какие — на nightly?
10. Приведите пример теста на границы (Boundary Value Analysis) для поля «возраст 1..120».

---

## Дополнительные практические задания (для студентов)

1. Напишите 5 unit-тестов для метода, который вычисляет скидку по правилам: VIP → 10%, сумма>1000 → 5%.
2. Составьте decision table для расчёта стоимости доставки (в зависимости от веса, региона и типа доставки).
3. Реализуйте простой E2E-тест (Playwright или Selenium) для страницы логина тестового сайта.
4. Подготовьте шаблон баг-репорта и приведите пример для найденной вами ошибки.