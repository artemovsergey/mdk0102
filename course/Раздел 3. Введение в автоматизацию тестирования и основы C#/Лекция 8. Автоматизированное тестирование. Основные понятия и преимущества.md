# Лекция 8. Автоматизированное тестирование: Основные понятия и преимущества

### **Тема**
Автоматизированное тестирование: Основные понятия, принципы, преимущества и первый опыт на .NET.

---

### **План лекции**

1.  **Введение: Что такое автоматизированное тестирование и зачем оно нужно?**
    *   Отличие ручного тестирования от автоматизированного.
    *   Цели и задачи автоматизации.
2.  **Основные понятия и архитектура автоматизированных тестов.**
    *   Пирамида тестирования Майка Кона.
    *   Типы автоматизированных тестов: Модульные, Интеграционные, Системные (E2E).
    *   Понятие "Тестовый случай", "Тестовый сценарий", "Assert" (Проверка).
3.  **Ключевые преимущества и недостатки автоматизации.**
    *   Когда автоматизация выгодна, а когда нет.
    *   Экономический аспект: ROI (Return on Investment).
4.  **Обзор инструментов и технологий в экосистеме .NET.**
    *   xUnit, NUnit, MSTest — фреймворки для модульного тестирования.
    *   Selenium WebDriver для E2E тестирования веб-приложений.
    *   Moq — библиотека для создания mock-объектов.
5.  **Практический пример: Пишем наш первый автоматизированный тест.**
    *   Тестирование простого метода на C#.
    *   Структура теста: Arrange, Act, Assert.
6.  **Резюме**
7.  **Контрольные вопросы**

---

### **Подробное рассмотрение каждого пункта плана**

#### **1. Введение: Что такое автоматизировантое тестирование и зачем оно нужно?**

**Что это?**
Автоматизированное тестирование — это процесс проверки программного обеспечения, при котором специальные программные средства (тестовые скрипты) выполняют тесты и сравнивают фактический результат с ожидаемым, без постоянного вмешательства человека.

**Аналогия из жизни:**
Представьте, что вы пекарь.
*   **Ручное тестирование:** Вы каждый раз пробуете новую партию хлеба на вкус, проверяете crust (корочку) и мякиш.
*   **Автоматизированное тестирование:** Вы создали машину, которая автоматически взвешивает каждую булку, проверяет ее цвет с помощью датчика и отбраковывает те, что не соответствуют стандарту.

**Ключевые цели:**
*   **Ускорение процесса:** Запуск 1000 тестов занимает минуты, а не дни.
*   **Повторяемость:** Тесты выполняются абсолютно одинаково каждый раз.
*   **Раннее обнаружение ошибок:** Интеграция в CI/CD (Continuous Integration / Continuous Delivery) позволяет находить баги сразу после внесения изменений в код.
*   **Тестирование того, что сложно проверить вручную:** Например, проверка работы приложения под нагрузкой (на 10 000 пользователей) или тестирование миграции больших объемов данных.

---

#### **2. Основные понятия и архитектура автоматизированных тестов.**

**а) Пирамида тестирования Майка Кона**

Это фундаментальная концепция, которая помогает распределить усилия по автоматизации.

*   **Основание (самый широкий слой): Модульные тесты (Unit Tests).**
    *   **Что тестируют:** Отдельные "единицы" кода — обычно методы или классы. Изолированы от внешних зависимостей (база данных, файловая система, сеть).
    *   **Кто пишет:** Разработчики.
    *   **Количество:** Больше всего. Десятки тысяч.
    *   **Скорость:** Очень быстрые (миллисекунды на тест).
    *   **Цель:** Проверить корректность логики отдельных компонентов.

*   **Середина: Интеграционные тесты (Integration Tests).**
    *   **Что тестируют:** Взаимодействие между несколькими компонентами (например, кодом приложения и базой данных, или двумя разными микросервисами).
    *   **Кто пишет:** Разработчики и тестировщики.
    *   **Количество:** Среднее. Сотни.
    *   **Скорость:** Медленнее, чем unit-тесты (секунды на тест).
    *   **Цель:** Убедиться, что компоненты правильно общаются друг с другом.

*   **Вершина (самый узкий слой): Сквозные тесты (End-to-End / E2E Tests).**
    *   **Что тестируют:** Полный сценарий работы приложения от начала до конца с точки зрения пользователя (например, "пользователь заходит на сайт, добавляет товар в корзину и оформляет заказ").
    *   **Кто пишет:** Тестировщики-автоматизаторы.
    *   **Количество:** Меньше всего. Десятки.
    *   **Скорость:** Самые медленные (минуты на тест).
    *   **Цель:** Проверить, что вся система работает корректно в условиях, максимально приближенных к реальным.

**Почему пирамида?** Потому что стабильную и надежную основу создают быстрые и дешевые unit-тесты. E2E-тесты — это "дорогая вишенка на торте", их не должно быть слишком много.

**б) Ключевые понятия**

*   **Test Case (Тестовый случай):** Формальное описание условий, шагов и ожидаемого результата.
*   **Test Script (Тестовый скрипт):** Код, который реализует тестовый случай.
*   **Assert (Проверка):** Ключевой оператор в тесте, который проверяет, соответствует ли фактический результат ожидаемому. Если нет — тест считается проваленным.
    *   *Пример:* `Assert.AreEqual(5, result);` // Ожидаем, что результат равен 5.

---

#### **3. Ключевые преимущества и недостатки автоматизации.**

**Преимущества (+):**

*   **Скорость и эффективность:** Повторяющиеся тесты выполняются быстро.
*   **Надежность:** Исключается человеческий фактор (усталость, невнимательность).
*   **Возможность регрессионного тестирования:** После каждого изменения в коде можно быть уверенным, что вы ничего не сломали в уже работающем функционале.
*   **Поддержка CI/CD:** Автотесты — неотъемлемая часть современных процессов разработки.

**Недостатки и ограничения (-):**

*   **Высокие первоначальные затраты:** Нужно время и деньги на написание фреймворка и тестов.
*   **Не может заменить человеческое мышление:** Автотест не найдет баг, который не был предсказан при его написании. Он не оценит удобство интерфейса.
*   **Сложность поддержки:** Если приложение часто меняется, тесты нужно постоянно обновлять, иначе они устаревают и начинают "ломаться" без реальных проблем в приложении (ложноположительные срабатывания).

**Когда автоматизация НЕ выгодна?**
*   Проект-однодневка, который скоро закроют.
*   UI приложения очень нестабилен и постоянно меняется.
*   Нужно провести исследовательское тестирование или проверить юзабилити.

---

#### **4. Обзор инструментов и технологий в экосистеме .NET.**

*   **xUnit / NUnit / MSTest:** Это фреймворки для написания модульных и интеграционных тестов. Они предоставляют атрибуты для пометки методов как тестов `[Fact]` (xUnit), `[Test]` (NUnit), `[TestMethod]` (MSTest) и набор Assert-методов.
    *   *Пример выбора:* xUnit часто считается более современным и гибким, MSTest встроен в Visual Studio.

*   **Selenium WebDriver:** "Золотой стандарт" для автоматизации браузера. Позволяет имитировать действия пользователя (клики, ввод текста, навигацию) в реальных браузерах (Chrome, Firefox). Используется для E2E-тестирования веб-приложений.

*   **Moq, NSubstitute:** Библиотеки для создания "заглушек" (mocks). Они позволяют изолировать тестируемый класс, подменяя его зависимости на контролируемые объекты-заглушки.
    *   *Пример:* Если метод использует базу данных, мы можем "создать mock" репозитория, который будет возвращать заранее заданные данные, не обращаясь к реальной БД.

---

#### **5. Практический пример: Пишем наш первый автоматизированный тест.**

**Задача:** Протестировать простой класс `Calculator`.

**Код тестируемого класса:**
```csharp
public class Calculator
{
    public int Add(int a, int b)
    {
        return a + b;
    }

    public double Divide(int a, int b)
    {
        if (b == 0)
            throw new DivideByZeroException("Cannot divide by zero.");
        return (double)a / b;
    }
}
```

**Код автоматизированного теста (используем xUnit):**

```csharp
using Xunit;

public class CalculatorTests
{
    [Fact] // Атрибут, который говорит xUnit, что это тестовый метод.
    public void Add_TwoPositiveNumbers_ReturnsCorrectSum()
    {
        // Arrange (Подготовка): Настраиваем все необходимое.
        var calculator = new Calculator();
        int number1 = 5;
        int number2 = 3;
        int expectedResult = 8;

        // Act (Действие): Выполняем тестируемое действие.
        int actualResult = calculator.Add(number1, number2);

        // Assert (Проверка): Проверяем результат.
        Assert.Equal(expectedResult, actualResult);
    }

    [Fact]
    public void Divide_DivideByZero_ThrowsDivideByZeroException()
    {
        // Arrange
        var calculator = new Calculator();
        int number1 = 10;
        int number2 = 0;

        // Act & Assert
        Assert.Throws<DivideByZeroException>(() => calculator.Divide(number1, number2));
    }
}
```

**Разбор примера:**
*   **Arrange:** Мы создаем экземпляр калькулятора и задаем входные данные.
*   **Act:** Мы вызываем метод, который хотим протестировать.
*   **Assert:** Мы используем метод `Assert.Equal` для проверки, что результат сложения корректен, и `Assert.Throws` для проверки, что исключение было выброшено.

---

### **Резюме**

1.  **Автоматизированное тестирование** — это мощный инструмент, который ускоряет разработку, повышает качество кода и позволяет быстро находить ошибки.
2.  **Пирамида тестирования** — это руководство по эффективному распределению усилий: много быстрых unit-тестов, меньше интеграционных и совсем немного медленных E2E-тестов.
3.  **Автоматизация — это инвестиция.** Она требует времени и ресурсов, но окупается на долгосрочных проектах с частыми релизами.
4.  **Инструменты в .NET (xUnit, Selenium, Moq)** образуют мощную экосистему для написания тестов любого уровня.
5.  **Структура "Arrange-Act-Assert"** — это фундаментальный шаблон для написания чистых и понятных тестов.

Помните: цель автоматизации — не заменить тестировщика, а освободить его время для более сложных, творческих и интересных задач, таких как исследовательское тестирование и тестирование удобства использования.

---

### **Контрольные вопросы**

1.  В чем основное различие между ручным и автоматизированным тестированием? Назовите по два преимущества каждого подхода.
2.  Объясните, что такое "Пирамида тестирования". Почему ее рекомендуют использовать?
3.  Какой тип тестов (Unit, Integration, E2E) следует использовать для проверки:
    *   Отдельного метода, который вычисляет налог?
    *   Процесса регистрации нового пользователя на сайте через веб-интерфейс?
    *   Взаимодействия между вашим приложением и внешним API платежной системы?
4.  Что такое "Ложноположительный результат" (False Positive) в автотестировании и чем он опасен?
5.  Опишите три фазы шаблона "Arrange-Act-Assert" на примере тестирования метода, который проверяет, является ли строка палиндромом.
6.  *Вопрос для размышления:* Представьте, что вы только начинаете автоматизировать тестирование в стартапе. С чего вы начнете: с модульных тестов или E2E-сценариев? Обоснуйте свой ответ, исходя из понятий ROI и Пирамиды тестирования.