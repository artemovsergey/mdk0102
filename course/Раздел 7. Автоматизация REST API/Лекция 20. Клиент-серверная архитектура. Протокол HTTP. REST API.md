# Лекция 20. Основы клиент-серверного взаимодействия для тестировщика

Клиент-серверная архитектура, протокол HTTP и REST API: основы для тестирования

---

### **План лекции:**

1.  **Введение в клиент-серверную архитектуру**
    *   Что такое клиент и сервер? Примеры из жизни.
    *   Роль тестировщика в клиент-серверной модели.

2.  **Протокол HTTP (HyperText Transfer Protocol) — основа веба**
    *   Что такое HTTP? Запрос и ответ.
    *   Структура HTTP-запроса (стартовая строка, заголовки, тело).
    *   Структура HTTP-ответа (статус-строка, заголовки, тело).
    *   Важнейшие HTTP-методы (GET, POST, PUT, DELETE, PATCH) и их идемпотентность.
    *   Коды состояния HTTP (1xx, 2xx, 3xx, 4xx, 5xx) — как их "читать" при тестировании.
    *   Понятие Stateless.

3.  **REST API (Representational State Transfer)**
    *   Что такое REST? Шесть архитектурных принципов.
    *   Ресурсы и URI (единообразие интерфейса).
    *   Примеры RESTful API в реальном мире.
    *   Чем REST отличается от простого HTTP?

4.  **Практика для тестировщика: Инструменты и подходы**
    *   Обзор инструментов для тестирования API (Postman, Swagger UI, curl, Fiddler).
    *   На что смотреть при тестировании API? (Позитивные, негативные сценарии, валидация данных, производительность).
    *   Пример тест-кейса для REST API.

5.  **Резюме**
6.  **Контрольные вопросы**

---

### **Подробное содержание лекции по пунктам плана**

#### **1. Введение в клиент-серверную архитектуру**

**Что такое клиент и сервер?**

Представьте себе ресторан.
*   **Клиент** — это вы, посетитель. Вы делаете заказ (запрос) и получаете еду (ответ).
*   **Сервер** — это кухня. Она принимает заказы, обрабатывает их (готовит) и возвращает готовые блюда.

В IT:
*   **Клиент** — это приложение, которое запрашивает данные или услуги. Примеры: веб-браузер (Chrome), мобильное приложение (Instagram), desktop-приложение (Slack).
*   **Сервер** — это мощный компьютер (или программа на нем), который предоставляет данные или услуги. Примеры: веб-сервер (Apache, Nginx), сервер приложений (написанный на .NET, Java, Node.js), сервер баз данных.

**Роль тестировщика в клиент-серверной модели:**
Наша главная задача — убедиться, что диалог между клиентом и сервером происходит корректно. Мы должны проверять:
*   Правильно ли клиент формирует запросы?
*   Правильно ли сервер их обрабатывает и возвращает ответы?
*   Что происходит, если клиент отправляет "битый" или неправильный запрос?
*   Как система ведет себя под нагрузкой (много клиентов одновременно)?

*Пример для .NET-тестировщика:* Вы тестируете веб-приложение на ASP.NET MVC. Ваш браузер (клиент) отправляет запрос на сервер IIS, где работает ваше ASP.NET-приложение (сервер). Вы проверяете, что при нажатии кнопки "Сохранить" форма отправляется (POST-запрос) и пользователь видит сообщение "Данные сохранены" (ответ 200 OK), а не "Ошибка 500".

---

#### **2. Протокол HTTP (HyperText Transfer Protocol)**

**Что такое HTTP?**
Это протокол "общения" между клиентом и сервером. Это набор правил, определяющих, как должны выглядеть запросы и ответы.

**Структура HTTP-запроса:**
```
GET /api/users/123 HTTP/1.1          // Стартовая строка: Метод + URI + Версия HTTP
Host: api.example.com                // Заголовки (Headers)
Authorization: Bearer abc123...      //
Content-Type: application/json       //
                                     // Пустая строка, разделяющая заголовки и тело
{"name": "John"}                     // Тело (Body) - есть не у всех запросов (есть у POST, PUT)
```

**Структура HTTP-ответа:**
```
HTTP/1.1 200 OK                      // Статус-строка: Версия HTTP + Код состояния + Пояснение
Content-Type: application/json       // Заголовки (Headers)
Server: Kestrel                      // (Да, это .NET-сервер!)
                                     // Пустая строка
{"id": 123, "name": "John", "email": "john@example.com"} // Тело (Body)
```

**Важнейшие HTTP-методы (для тестировщика это — КРИТИЧЕСКИ ВАЖНО):**
*   **GET** — получение данных. *Идемпотентный* (сколько раз ни выполни — результат тот же). *Безопасный* (не меняет данные на сервере).
    *   *Пример:* `GET /api/products` — получить список товаров.
*   **POST** — создание нового ресурса. *Неидемпотентный*.
    *   *Пример:* `POST /api/users` — создать нового пользователя (тело запроса содержит данные пользователя).
*   **PUT** — полное обновление ресурса. *Идемпотентный*. (Если отправить один и тот же запрос дважды, состояние ресурса не изменится со второго раза).
    *   *Пример:* `PUT /api/users/123` — полностью обновить данные пользователя с id=123.
*   **PATCH** — частичное обновление ресурса. *Неидемпотентный* (но на практике часто считается таковым).
    *   *Пример:* `PATCH /api/users/123` {"email": "new@email.com"} — изменить только email.
*   **DELETE** — удаление ресурса. *Идемпотентный*.
    *   *Пример:* `DELETE /api/users/123` — удалить пользователя.

**Коды состояния HTTP (наше "меню" ошибок):**
*   **1xx (Информационные)** — редко видит тестировщик.
*   **2xx (Успех)** — всё хорошо!
    *   `200 OK` — успешный запрос.
    *   `201 Created` — ресурс создан (часто в ответ на POST).
    *   `204 No Content` — успешно, но тело ответа пустое (часто после DELETE).
*   **3xx (Перенаправление)** —
    *   `301 Moved Permanently` — ресурс перемещен на новый URI.
*   **4xx (Ошибка клиента)** — ВИНА КЛИЕНТА. Мы отправили плохой запрос.
    *   `400 Bad Request` — общая ошибка, сервер не понял запрос (например, невалидный JSON в теле).
    *   `401 Unauthorized` — требуется аутентификация (ты кто?).
    *   `403 Forbidden` — доступ запрещен (ты кто-то, но тебе нельзя).
    *   `404 Not Found` — ресурс не найден.
    *   `405 Method Not Allowed` — метод (GET/POST) не поддерживается для данного URI.
    *   `429 Too Many Requests` — слишком много запросов (защита от DDoS).
*   **5xx (Ошибка сервера)** — ВИНА СЕРВЕРА. Сервер не смог обработать корректный запрос.
    *   `500 Internal Server Error` — общая ошибка сервера ("упал" Exception в .NET-коде).
    *   `502 Bad Gateway` — прокси-сервер получил invalid response от upstream-сервера.
    *   `503 Service Unavailable` — сервер временно перегружен или на обслуживании.

**Stateless (Без состояния)**
HTTP не помнит предыдущие запросы. Каждый запрос полностью самодостаточен и должен содержать всю информацию, необходимую для его обработки. Сессии реализуются с помощью кук, токенов (JWT) и т.д.

---

#### **3. REST API (Representational State Transfer)**

**Что такое REST?**
Это не протокол, а архитектурный стиль, набор рекомендаций по построению предсказуемых и удобных API поверх HTTP.

**Шесть принципов REST (для тестировщика важны первые 3):**
1.  **Единообразие интерфейса (Uniform Interface):** Самый важный! URI — это ресурсы.
    *   Ресурсы идентифицируются URI. `/api/users`, `/api/users/123`.
    *   Манипуляции с ресурсами через HTTP-методы (CRUD: Create, Read, Update, Delete).
    *   Самодостаточные сообщения (запрос/ответ содержит всё для понимания).
2.  **Отсутствие состояния (Stateless):** Как и в HTTP.
3.  **Кэшируемость (Cacheable):** Ответы сервера должны помечаться как кэшируемые или нет.
4.  **Клиент-серверная архитектура.**
5.  **Многоуровневая система.**
6.  **Код по требованию (опционально).**

**Ресурсы и URI:**
Ресурс — это сущность (пользователь, товар, заказ).
*   Получить список пользователей: `GET /users`
*   Получить пользователя с ID=10: `GET /users/10`
*   Создать нового пользователя: `POST /users`
*   Обновить пользователя 10: `PUT /users/10`
*   Удалить пользователя 10: `DELETE /users/10`

**Примеры RESTful API:** GitHub API, Twitter API, Google Maps API. Большинство современных бэкендов предоставляют REST API.

**Чем REST отличается от простого HTTP?**
REST — это правильное использование HTTP. "Плохое" (не-REST) API могло бы выглядеть так:
`GET /getUser?id=10`, `POST /updateUser`, `GET /deleteUser?id=10`. Здесь HTTP-методы используются не по назначению. RESTful API использует мощность HTTP по максимуму.

---

#### **4. Практика для тестировщика: Инструменты и подходы**

**Инструменты:**
*   **Postman** — "золотой стандарт". Позволяет создавать коллекции запросов, писать автоматизированные тесты на JavaScript, настроить окружения. *Обязателен к изучению!*
*   **Swagger UI / OpenAPI** — интерактивная документация API. Часто разработчики предоставляют её тестировщикам. Позволяет "поиграться" с API прямо в браузере.
*   **curl** — консольная утилита. Мощный инструмент для автоматизации в скриптах.
    *   *Пример:* `curl -X GET https://api.github.com/users/octocat`
*   **Fiddler / Charles Proxy** — прокси-отладчики. Позволяют перехватывать и анализировать весь трафик между клиентом и сервером. Незаменимы при отладке мобильных приложений.

**На что смотреть при тестировании API?**
1.  **Позитивные сценарии:** Отправляем валидные данные, проверяем `2xx` ответ и корректное тело.
2.  **Негативные сценарии:**
    *   Валидация: отправляем строку вместо числа, отрицательный возраст, email без `@`. Ожидаем `400 Bad Request`.
    *   Отсутствие ресурса: `GET /users/999999` → `404 Not Found`.
    *   Отсутствие прав: запрос без токена → `401 Unauthorized`.
    *   Неверный метод: `POST /users/10` вместо `PUT` → `405 Method Not Allowed`.
3.  **Безопасность:** Проверка авторизации, SQL-инъекции (через параметры), XSS.
4.  **Производительность:** Замер времени ответа (должен быть < 200-500мс для большинства операций). Нагрузочное тестирование.

**Пример тест-кейса для REST API:**
*   **Объект тестирования:** `POST /api/users`
*   **Предусловия:** Указан валидный API-ключ в заголовках.
*   **Тестовые данные:** `{"name": "Alice", "email": "alice@example.com"}`
*   **Шаги:**
    1.  Отправить POST-запрос с тестовыми данными.
    2.  Проверить код ответа (`201 Created`).
    3.  Проверить, что в теле ответа есть `id` нового пользователя и переданные `name` и `email`.
    4.  Выполнить `GET /api/users/{new_id}` и убедиться, что пользователь создался в системе.

---

### **5. Резюме**

1.  **Клиент-сервер** — фундаментальная модель, где клиент запрашивает, а сервер предоставляет.
2.  **HTTP** — это язык их общения. Мы, тестировщики, должны досконально знать его структуру: методы, коды состояния, заголовки.
3.  **REST** — это "хорошие манеры" при построении API на основе HTTP. Он делает API предсказуемым и удобным.
4.  **Тестирование API** — это проверка этого диалога. Мы используем Postman, Swagger, пишем позитивные и негативные сценарии, проверяем безопасность и производительность.
5.  **Как .NET-тестировщик**, вы будете часто работать с API, написанными на ASP.NET Web API или аналогичных фреймворках. Понимание этих основ позволит вам эффективно находить дефекты не только на UI, но и на более глубоком, бизнес-логическом уровне.

---

### **6. Контрольные вопросы**

1.  Объясните принцип клиент-серверной архитектуры на бытовом примере, отличном от приведенного в лекции.
2.  В чем разница между HTTP-методами GET и POST? А между PUT и PATCH?
3.  Какие HTTP-коды состояния вы получите в следующих сценариях?
    *   Попытка удалить несуществующего пользователя.
    *   Создание нового товара без указания его названия (если оно обязательно).
    *   Отправка запроса с неверным форматом JSON в теле.
    *   Успешное создание нового заказа.
4.  Что означает принцип "Stateless" в HTTP и почему он важен?
5.  Является ли API RESTful, если все его эндпоинты выглядят как `/api/getData` и `/api/saveData`? Почему?
6.  Назовите три инструмента, которые вы бы использовали для тестирования REST API, и кратко опишите назначение каждого.
7.  Составьте пример негативного тест-кейса для эндпоинта `GET /api/orders/{id}`, который возвращает информацию о заказе.