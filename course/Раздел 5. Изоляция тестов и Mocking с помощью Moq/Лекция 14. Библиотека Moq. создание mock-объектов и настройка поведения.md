# Лекция 14. Библиотека Moq — создание mock-объектов и настройка поведения

## **Цель лекции**

Познакомить студентов с основными возможностями библиотеки **Moq** и научить:

* создавать mock-объекты для интерфейсов и классов;
* настраивать возвращаемое поведение;
* проверять взаимодействия между объектами;
* различать типы настроек (`Setup`, `Verify`, `Callback`, `Returns`, `Throws`);
* эффективно применять Moq для модульного тестирования бизнес-логики.

---

## **План**

1. Что такое Moq и зачем он нужен
2. Установка и подключение библиотеки
3. Создание mock-объектов
4. Настройка поведения (`Setup`, `Returns`, `Throws`)
5. Проверка взаимодействий (`Verify`)
6. Дополнительные возможности Moq: `It`, `Callback`, `Sequence`, `SetupProperty`
7. Примеры сложных сценариев
8. Антипаттерны и ошибки при работе с Moq
9. Резюме
10. Контрольные вопросы

---

## 1. Что такое Moq и зачем он нужен

**Moq** — это популярная библиотека для создания тестовых дублеров (mock-объектов) в .NET.
Она используется, чтобы **имитировать зависимости** в тестах, проверять взаимодействие между компонентами и задавать контролируемое поведение.

**Главные преимущества:**

* Простота API, поддержка fluent-интерфейса.
* Автоматическая генерация объектов по интерфейсам и виртуальным методам.
* Возможность проверки вызовов, аргументов, количества обращений.
* Работает с `xUnit`, `NUnit`, `MSTest`.

---

## 2. Установка и подключение

Добавляем пакет Moq в тестовый проект:

```bash
dotnet add package Moq
```

Подключаем пространство имён:

```csharp
using Moq;
```

---

## 3. Создание mock-объектов

Mock можно создать для любого интерфейса или класса с виртуальными методами.

```csharp
public interface IWeatherService
{
    int GetTemperature(string city);
}
```

**Создание mock:**

```csharp
var mockWeather = new Mock<IWeatherService>();
```

**Получение объекта для передачи в тестируемый класс:**

```csharp
var service = new ForecastApp(mockWeather.Object);
```

Теперь `mockWeather.Object` можно использовать как «поддельный» сервис в тестах.

---

## 4. Настройка поведения (`Setup`, `Returns`, `Throws`)

### 4.1 Метод `Setup`

Позволяет указать, **что должен возвращать** мок при вызове определённого метода.

```csharp
mockWeather
    .Setup(s => s.GetTemperature("Moscow"))
    .Returns(25);
```

Теперь при вызове `GetTemperature("Moscow")` мок вернёт `25`.

---

### 4.2 Использование `It` для гибкости аргументов

```csharp
mockWeather
    .Setup(s => s.GetTemperature(It.IsAny<string>()))
    .Returns(20);
```

`It.IsAny<string>()` означает: “любой аргумент типа string”.

---

### 4.3 Возврат динамических значений

```csharp
mockWeather
    .Setup(s => s.GetTemperature(It.IsAny<string>()))
    .Returns((string city) => city == "Moscow" ? 25 : 15);
```

---

### 4.4 Генерация исключений

```csharp
mockWeather
    .Setup(s => s.GetTemperature("Antarctica"))
    .Throws(new Exception("Too cold!"));
```

---

### 4.5 Настройка асинхронных методов

```csharp
mockWeather
    .Setup(s => s.GetTemperatureAsync(It.IsAny<string>()))
    .ReturnsAsync(30);
```

---

## 5. Проверка взаимодействий (`Verify`)

**`Verify`** используется, чтобы убедиться, что метод был вызван определённое количество раз и с нужными параметрами.

```csharp
mockWeather.Verify(s => s.GetTemperature("Moscow"), Times.Once);
```

**Примеры:**

* `Times.Never()` — метод не должен быть вызван.
* `Times.Once()` — должен быть вызван 1 раз.
* `Times.Exactly(n)` — ровно `n` раз.
* `Times.AtLeastOnce()` — хотя бы 1 раз.

---

### Пример полного теста

```csharp
[Fact]
public void Should_Get_Weather_And_Display_Message()
{
    var mockWeather = new Mock<IWeatherService>();
    mockWeather
        .Setup(s => s.GetTemperature("Moscow"))
        .Returns(25);

    var app = new ForecastApp(mockWeather.Object);

    app.ShowForecast("Moscow");

    mockWeather.Verify(s => s.GetTemperature("Moscow"), Times.Once);
}
```

---

## 6. Дополнительные возможности Moq

### 6.1 `Callback` — отлавливаем вызовы

Позволяет выполнить код при вызове метода.

```csharp
int callCount = 0;

mockWeather
    .Setup(s => s.GetTemperature(It.IsAny<string>()))
    .Callback(() => callCount++)
    .Returns(22);
```

Теперь при каждом вызове счётчик увеличивается.

---

### 6.2 Проверка аргументов через `It.Is<T>()`

```csharp
mockWeather
    .Setup(s => s.GetTemperature(It.Is<string>(city => city.StartsWith("M"))))
    .Returns(28);
```

---

### 6.3 `SetupSequence` — последовательное поведение

```csharp
mockWeather.SetupSequence(s => s.GetTemperature("Moscow"))
    .Returns(25)
    .Returns(26)
    .Throws(new Exception("Sensor error"));
```

Каждый вызов возвращает разное значение.

---

### 6.4 `SetupProperty` и `SetupAllProperties`

Иногда нужно, чтобы свойства у мока **вели себя как настоящие** (хранили данные).

```csharp
var mock = new Mock<IUserSettings>();
mock.SetupAllProperties();

mock.Object.Name = "Alex";
Assert.Equal("Alex", mock.Object.Name);
```

---

### 6.5 `MockBehavior.Strict` и `MockBehavior.Loose`

* **Loose** (по умолчанию): если метод не настроен — возвращает default (null, 0).
* **Strict**: любое неописанное поведение вызывает исключение.

```csharp
var strictMock = new Mock<IWeatherService>(MockBehavior.Strict);
```

---

## 7. Примеры сложных сценариев

### 7.1 Мок для репозитория

```csharp
public interface IUserRepository
{
    Task<User> GetUserAsync(int id);
    Task SaveAsync(User user);
}

var mockRepo = new Mock<IUserRepository>();

mockRepo
    .Setup(r => r.GetUserAsync(1))
    .ReturnsAsync(new User { Id = 1, Name = "Alex" });

mockRepo
    .Setup(r => r.SaveAsync(It.IsAny<User>()))
    .Callback<User>(u => Console.WriteLine($"Saving {u.Name}"));
```

---

### 7.2 Проверка, что метод вызван с конкретным объектом

```csharp
mockRepo.Verify(r => r.SaveAsync(It.Is<User>(u => u.Id == 1 && u.Name == "Alex")), Times.Once);
```

---

### 7.3 Мок цепочки вызовов

Для таких случаев используют `Setup` с `Returns`:

```csharp
mockRepo.Setup(r => r.GetUserAsync(It.IsAny<int>()))
        .ReturnsAsync(new User { Id = 42 })
        .Verifiable("User should be fetched once");
```

Потом:

```csharp
mockRepo.Verify();
```

---

## 8. Антипаттерны и типичные ошибки

| Ошибка                                     | Почему плохо                               | Альтернатива                           |
| ------------------------------------------ | ------------------------------------------ | -------------------------------------- |
| Over-mocking                               | тесты проверяют реализацию, а не поведение | Мокать только внешние зависимости      |
| Дублирование Setup в каждом тесте          | сложно сопровождать                        | Вынести в `Setup()` или фикстуру       |
| Использование `It.IsAny<T>()` без проверки | теряется смысл проверки                    | Лучше `It.Is<T>(predicate)`            |
| Мокирование внутренних методов             | нарушает инкапсуляцию                      | тестируй через публичный интерфейс     |
| Использование Strict везде                 | тесты становятся хрупкими                  | использовать строгое поведение точечно |

---

## 9. Резюме

* **Moq** — мощный инструмент для создания поддельных зависимостей в тестах.
* С его помощью можно:

  * задавать поведение (`Setup`, `Returns`, `Throws`);
  * проверять взаимодействие (`Verify`);
  * использовать гибкие проверки (`It.Is`, `Callback`, `Sequence`).
* Главное правило — мокать **только внешние зависимости**, а не тестируемую логику.
* Хороший мок — это простой, читаемый и понятный дублёр, который делает тест изолированным.

---

## 10. Контрольные вопросы

1. Что делает библиотека Moq и зачем она нужна?
2. Чем отличается `Setup` от `Verify`?
3. Как вернуть значение из мока в зависимости от аргумента?
4. Как задать последовательность разных возвратов при нескольких вызовах одного метода?
5. Что делает метод `Callback` и когда он полезен?
6. Как проверить, что метод был вызван один раз с конкретным аргументом?
7. В чём разница между `MockBehavior.Strict` и `MockBehavior.Loose`?
8. Почему не рекомендуется мокать внутренние методы тестируемого класса?
9. Что произойдёт, если вызвать метод, не настроенный в Strict mock?
10. Как настроить mock, чтобы его свойства сохраняли состояние (например, `Name`)?
