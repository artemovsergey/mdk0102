# Лекция 13. Зачем нужны моки. Введение в изоляцию зависимостей

## План лекции

1. Мотивация: зачем изолировать зависимости?
2. Виды дублеров: stub / fake / mock / spy / dummy — отличия и примеры.
3. Контракт зависимости: интерфейсы и абстракции — почему это важно.
4. Техники инъекции зависимостей: конструктор, метод, сервис-локатор — плюсы/минусы.
5. Базовая работа с моками в .NET (пример на Moq).
6. Реальные примеры: БД, сетевые запросы (HttpClient), время/таймеры, очередь сообщений.
7. Психология теста: что мокать, а что нет; интеграционные vs модульные тесты; антипаттерны.
8. Повышение устойчивости тестов: настройка ожиданий, тесты на контракт, loose vs strict mocks.
9. Практические советы и чек-лист при написании тестов с моками.
10. Резюме и контрольные вопросы.

---

# 1. Мотивация: зачем изолировать зависимости?

**Коротко:** чтобы тесты были быстрыми, надёжными, атомарными и сосредоточенными на поведении тестируемого кода (SUT — System Under Test).

**Проблемы без изоляции:**

* Медленные тесты (реальная БД, сеть).
* Нестабильность (сеть/внешние сервисы падают).
* Трудно воспроизводимые сценарии (время, состояние внешней системы).
* Тесты проверяют интеграцию, а не логику компонента — сложно локализовать баги.
* Неудобно моделировать ошибки (timeouts, 500, исключения).

**Пример:** метод `PlaceOrder(order)` вызывает платёжный шлюз и сохраняет в БД.

* Без моков: тест создаёт запись в БД и делает реальный запрос к платёжнику — долго, ненадёжно, требует тест-аккаунтов.
* С моками: мок платёжника возвращает нужный ответ, а мок репозитория проверяет, что был вызов сохранения — тест быстрый и фокусируется на логике `PlaceOrder`.

---

# 2. Виды дублеров и их отличия

Ключевые термины и их смысл на практике:

* **Dummy** — объект, передаваемый в метод, но не используемый (например, `null`-заменитель аргумента).

  ```csharp
  var dummyLogger = new NullLogger();
  ```
* **Stub** — предоставляет заранее подготовленные данные (поведение простое, не проверяемое взаимодействие).

  * Пример: `IWeatherService.GetTemperature()` возвращает 20°C.
* **Fake** — рабочая реализация с упрощённой логикой (встроенная тестовая БД в памяти).

  * Пример: in-memory репозиторий `InMemoryUserRepository`.
* **Mock** — проверяемый объект: мы задаём ожидания (какие методы и с какими аргументами должны быть вызваны).

  * Пример: проверить, что `ILogger.Log("Ошибка")` вызван ровно 1 раз.
* **Spy** — гибрид stub+mock: обычно собирает информацию о вызовах, но не налагает строгих ожиданий заранее.

**Когда что выбирать:**

* Нужны только данные → stub.
* Нужна рабочая, но упрощённая система → fake.
* Нужен контроль взаимодействия — проверка вызовов → mock/spy.

---

# 3. Контракт зависимости: интерфейсы и абстракции

**Почему интерфейсы?**

* Позволяют заменять реальные реализации тестовыми дублерами.
* Делают код testable: класс зависит от абстракции, а не от реализации.
* Улучшают дизайн (SRP, инверсия зависимостей).

**Пример интерфейса:**

```csharp
public interface IPaymentGateway
{
    Task<PaymentResult> ChargeAsync(CardInfo card, decimal amount);
}
```

Тестируемый класс использует `IPaymentGateway`, что позволяет подставить мок в тесте.

**Совет:** не делайте интерфейс только ради тестов — он часто полезен и в проекте (особенно для внешних/IO зависимостей).

---

# 4. Техники инъекции зависимостей

### Конструкторная инъекция (рекомендуется)

```csharp
public class OrderService
{
    private readonly IPaymentGateway _payment;
    public OrderService(IPaymentGateway payment) { _payment = payment; }
}
```

Плюсы: зависимости видны явно, удобно тестировать.

### Инъекция через метод (parameter injection)

```csharp
public void Process(Order order, IPaymentGateway payment) { ... }
```

Используется редко, удобно для временных замен.

### Сервис-локатор / ServiceProvider (антипаттерн для тестируемости)

```csharp
var payment = serviceProvider.GetService<IPaymentGateway>();
```

Минусы: скрытые зависимости, сложно монтировать моки.

**Рекомендация:** предпочитайте конструкторную инъекцию, избегайте сервис-локатора для новых классов.

---

# 5. Базовая работа с моками в .NET (пример на Moq)

Установим Moq (в тестовом проекте): `dotnet add package Moq`

**Пример:**

```csharp
public class OrderService
{
    private readonly IPaymentGateway _payment;
    private readonly IOrderRepository _repo;
    public OrderService(IPaymentGateway payment, IOrderRepository repo)
    {
        _payment = payment;
        _repo = repo;
    }

    public async Task<bool> PlaceOrderAsync(Order order, CardInfo card)
    {
        var result = await _payment.ChargeAsync(card, order.Total);
        if (!result.Success) return false;
        order.Status = OrderStatus.Paid;
        await _repo.SaveAsync(order);
        return true;
    }
}
```

Тест с Moq:

```csharp
[Fact]
public async Task PlaceOrder_PaymentSuccess_SavesOrder()
{
    var mockPayment = new Mock<IPaymentGateway>();
    mockPayment
        .Setup(p => p.ChargeAsync(It.IsAny<CardInfo>(), It.IsAny<decimal>()))
        .ReturnsAsync(new PaymentResult { Success = true });

    var mockRepo = new Mock<IOrderRepository>();

    var service = new OrderService(mockPayment.Object, mockRepo.Object);
    var order = new Order { Total = 100m };

    var result = await service.PlaceOrderAsync(order, new CardInfo());

    Assert.True(result);
    Assert.Equal(OrderStatus.Paid, order.Status);
    mockRepo.Verify(r => r.SaveAsync(order), Times.Once);
}
```

**Пояснения:**

* `Setup` — задаёт поведение (stub).
* `Verify` — проверяет взаимодействие (mock).
* `It.IsAny<T>()` — соответствует любому аргументу типа `T`.

---

# 6. Практические примеры из реальной жизни

### 6.1 База данных (репозитории)

Подмена репозитория мок-объектом или использование `InMemory`-Fake (например, EF Core InMemory provider).

**Мок репозитория:**

```csharp
mockRepo.Setup(r => r.GetByIdAsync(1)).ReturnsAsync(new User { Id = 1 });
```

**Fake (InMemory):**

* Когда нужна «реальная» логика (LINQ-запросы) — используем InMemory-реализацию.
* Минус: InMemory EF может вести себя иначе, чем реальный SQL.

### 6.2 HttpClient / внешние API

`HttpClient` не интерфейс, поэтому мокать нужно `HttpMessageHandler` или оборачивать в интерфейс `IHttpClient`/`IExternalApiClient`.

**Мок HttpMessageHandler:**

```csharp
var handlerMock = new Mock<HttpMessageHandler>(MockBehavior.Strict);
handlerMock
  .Protected()
  .Setup<Task<HttpResponseMessage>>(
     "SendAsync",
     ItExpr.IsAny<HttpRequestMessage>(),
     ItExpr.IsAny<CancellationToken>()
  )
  .ReturnsAsync(new HttpResponseMessage(HttpStatusCode.OK) {
      Content = new StringContent("{\"ok\":true}")
  });

var httpClient = new HttpClient(handlerMock.Object);
```

Или — создать `IWeatherClient` и мокать его проще.

### 6.3 Время / таймеры

Частая зависимость: `DateTime.UtcNow`. Решение: абстрагировать через `IDateTimeProvider`.

```csharp
public interface IClock { DateTime UtcNow { get; } }
```

В тесте: `mockClock.Setup(c => c.UtcNow).Returns(new DateTime(2020,1,1));`

### 6.4 Очереди/шины сообщений

* Мокать интерфейс отправки сообщений.
* Тестировать, что сообщение сформировано и отправлено (Verify).

---

# 7. Что мокать, а что — нет. Интеграционные vs модульные тесты

**Модульные (unit) тесты**: мокать всё внешнее — фокус на отдельном классе.
**Интеграционные тесты**: использовать реальные зависимости (или тестовые окружения: test DB, тестовый сервис), проверять взаимодействие компонентов.

**Правила:**

* Мокаем внешние IO (Сеть, ФС, БД) в модульных тестах.
* Не мокаем «внутреннюю бизнес-логику» одного слоя — лучше тестировать реализацию.
* Не мокать слишком много — иначе тест будет проверять только вызовы, но не бизнес-логику (over-mocking).

**Антипаттерны:**

* Мокать все вызовы, включая простые POCO-методы — тест бесполезен.
* Строгое мокирование реализационной последовательности (ordering) — тесты хрупкие.
* Тестирование внутренних приватных методов, вместо публичного API.

---

# 8. Повышение устойчивости тестов

### Loose vs Strict mocks

* **Loose (по умолчанию)**: если вызван метод без Setup — возвращается default, тест не падает.
* **Strict**: любой неожиданный вызов приводит к ошибке — полезно для проверки контрактов, но увеличивает хрупкость.

### Подходы

* Сосредоточьтесь на поведении (what), а не на реализации (how).
* Используйте `It.Is<T>(predicate)` для гибкого сопоставления аргументов.
* Не используйте `Times.AtLeastOnce()` без причины; предпочтительно `Times.Once()` или `Times.Never()`.

**Пример гибкой проверки аргументов:**

```csharp
mockRepo.Verify(r => r.SaveAsync(It.Is<Order>(o => o.Total == 100m && o.Status == OrderStatus.Paid)), Times.Once);
```

---

# 9. Практические советы и чек-лист

**Чек-лист при написании теста:**

1. Определите SUT и внешние зависимости.
2. Абстрагируйте зависимости через интерфейсы.
3. Используйте конструкторную инъекцию.
4. Stub — для возвращаемых данных; Mock — для проверки вызовов.
5. Предпочитайте простые, быстрые тесты (в памяти, без сети/БД).
6. Избегайте over-mocking: тестируйте поведение, а не реализацию.
7. Используйте InMemory или облегчённые Fake, если нужно «реальное» поведение.
8. Document expectations в тесте (что именно проверяется и почему).
9. Если тест стал сложным из-за большого числа mock-setup — возможно это знак, что класс слишком большой (нужна рефакторинг).
10. Периодически запускайте интеграционные тесты в CI, чтобы проверить реальные интеграции.

---

# 10. Резюме (коротко)

* Моки и другие дублеры нужны, чтобы тесты были быстрыми, надёжными и локализованными.
* Используйте интерфейсы и конструкторную инъекцию, чтобы сделать код тестируемым.
* Различайте стобы/фейки/моки/спаи и применяйте по назначению.
* Не мокайте всё подряд — держите баланс между модульными и интеграционными тестами.
* Пиши тесты на поведение, делай их читаемыми и устойчивыми.

---

## Контрольные вопросы

1. Почему важно изолировать зависимости при модульном тестировании?
2. В чём разница между stub, fake и mock? Приведите пример для каждого.
3. Почему предпочтительнее конструкторная инъекция по сравнению с сервис-локатором?
4. Как замокать `HttpClient` в тесте? Какие есть альтернативы?
5. Что такое over-mocking и какие проблемы он создаёт?
6. Когда лучше использовать InMemory-реализацию вместо мок-объекта?
7. Как проверить, что метод был вызван с правильными аргументами (пример на Moq)?
8. Что такое strict mock и когда его использовать?
9. Какие сигналы в тестах говорят о необходимости рефакторинга SUT?
10. Приведите пример абстракции для `DateTime.UtcNow` и объясните, почему она полезна.

---

## Ключевые ответы (коротко)

1. Изоляция даёт скорость, предсказуемость и фокус на поведении — исключает влияние внешних факторов.
2. Stub — возвращает данные; Fake — рабочая упрощённая реализация; Mock — объект, у которого проверяются вызовы. Примеры выше (репозиторий, InMemoryRepo, Moq-Verify).
3. Конструкторная инъекция делает зависимости явными и тестируемыми; сервис-локатор скрывает зависимости.
4. Мокать `HttpMessageHandler` либо инкапсулировать `HttpClient` за интерфейсом `IHttpClient`.
5. Over-mocking делает тесты хрупкими и проверяет реализацию, а не поведение.
6. Когда нужна реальная логика (например, LINQ-запросы) или тестируемая интеграция внутри одного слоя.
7. `mock.Verify(x => x.DoSomething(It.Is<MyType>(t => t.Prop == value)), Times.Once);`
8. Strict mock падает при любом неожиданном вызове — полезен для проверки контрактов, но делает тесты хрупкими.
9. Много `Setup`/`Verify`, сложные начальные данные, длинные тесты — признак, что SUT слишком сложный.
10. `public interface IClock { DateTime UtcNow { get; } }` — позволяет фиксировать время в тестах.
