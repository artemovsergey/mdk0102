# Практическая работа 6. Написание параметризированных тестов в xUnit

## **Тема**
Освоение техники параметризированного тестирования с использованием атрибутов Theory, InlineData, MemberData и ClassData в xUnit.

## **Цель**
Научить студентов создавать параметризированные тесты для эффективного покрытия различных сценариев:
- Использование атрибутов Theory и InlineData
- Применение MemberData для сложных наборов данных
- Использование ClassData для организации тестовых данных
- Снижение дублирования кода в тестах

## **Теоретическая часть**

**Параметризированные тесты** - это техника, позволяющая выполнять один тестовый метод многократно с разными наборами входных данных и ожидаемых результатов.

### **Основные атрибуты для параметризации:**

**1. `[Theory]`**
Заменяет атрибут `[Fact]` и указывает, что тестовый метод принимает параметры и должен выполняться с разными наборами данных.

**2. `[InlineData]`**
Позволяет передавать данные напрямую в атрибуте. Подходит для простых случаев.

```csharp
[Theory]
[InlineData(2, 2, 4)]
[InlineData(3, 5, 8)]
[InlineData(0, 0, 0)]
public void Add_TwoNumbers_ReturnsSum(int a, int b, int expected)
{
    // Тест выполнится 3 раза с разными данными
}
```

**3. `[MemberData]`**
Позволяет использовать данные из свойства или метода класса. Подходит для сложных наборов данных.

```csharp
public static IEnumerable<object[]> TestData =>
    new List<object[]>
    {
        new object[] { 1, 1, 2 },
        new object[] { 2, 3, 5 }
    };

[Theory]
[MemberData(nameof(TestData))]
public void Add_WithMemberData_ReturnsSum(int a, int b, int expected)
{
    // Использование данных из свойства
}
```

**4. `[ClassData]`**
Позволяет вынести тестовые данные в отдельный класс. Идеально для организации больших наборов данных.

```csharp
public class CalculatorTestData : IEnumerable<object[]>
{
    public IEnumerator<object[]> GetEnumerator()
    {
        yield return new object[] { 1, 1, 2 };
        yield return new object[] { 2, 2, 4 };
    }
    
    IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();
}

[Theory]
[ClassData(typeof(CalculatorTestData))]
public void Add_WithClassData_ReturnsSum(int a, int b, int expected)
{
    // Использование данных из отдельного класса
}
```

## **Ход работы**

1. Создайте решение с двумя проектами:
   - **Проект приложения**: `ParametrizedTestsDemo`
   - **Тестовый проект**: `ParametrizedTestsDemo.Tests`

2. Реализуйте класс согласно вашему варианту задания

3. Создайте параметризированные тесты, используя все три способа подачи данных:
   - `[InlineData]` для простых случаев
   - `[MemberData]` для средних наборов данных  
   - `[ClassData]` для сложных структур данных

4. Убедитесь, что все тесты проходят

5. Создайте папку `images` со скриншотом результатов

6. Оформите README.md согласно требованиям

## **Практический пример**

**Проект приложения:**
```csharp
namespace ParametrizedTestsDemo
{
    public class MathCalculator
    {
        public int Add(int a, int b) => a + b;
        
        public bool IsPrime(int number)
        {
            if (number <= 1) return false;
            if (number == 2) return true;
            if (number % 2 == 0) return false;
            
            for (int i = 3; i <= Math.Sqrt(number); i += 2)
            {
                if (number % i == 0)
                    return false;
            }
            
            return true;
        }
        
        public double CalculateCircleArea(double radius)
        {
            if (radius <= 0)
                throw new ArgumentException("Radius must be positive");
                
            return Math.PI * radius * radius;
        }
    }
}
```

**Тестовый проект:**
```csharp
using Xunit;
using ParametrizedTestsDemo;

namespace ParametrizedTestsDemo.Tests
{
    public class MathCalculatorTests
    {
        private readonly MathCalculator _calculator;

        public MathCalculatorTests()
        {
            _calculator = new MathCalculator();
        }

        // Тестирование с InlineData - для простых случаев
        [Theory]
        [InlineData(1, 1, 2)]
        [InlineData(0, 0, 0)]
        [InlineData(-1, 1, 0)]
        [InlineData(100, 200, 300)]
        public void Add_VariousNumbers_ReturnsCorrectSum(int a, int b, int expected)
        {
            // Act
            int result = _calculator.Add(a, b);

            // Assert
            Assert.Equal(expected, result);
        }

        // Тестирование с MemberData - для средних наборов данных
        public static IEnumerable<object[]> PrimeTestData =>
            new List<object[]>
            {
                new object[] { 2, true },
                new object[] { 3, true },
                new object[] { 4, false },
                new object[] { 17, true },
                new object[] { 1, false },
                new object[] { 0, false },
                new object[] { -5, false }
            };

        [Theory]
        [MemberData(nameof(PrimeTestData))]
        public void IsPrime_VariousNumbers_ReturnsCorrectResult(int number, bool expected)
        {
            // Act
            bool result = _calculator.IsPrime(number);

            // Assert
            Assert.Equal(expected, result);
        }

        // Тестирование исключений с параметризацией
        [Theory]
        [InlineData(0)]
        [InlineData(-1)]
        [InlineData(-10.5)]
        public void CalculateCircleArea_InvalidRadius_ThrowsException(double radius)
        {
            // Act & Assert
            Assert.Throws<ArgumentException>(() => _calculator.CalculateCircleArea(radius));
        }
    }

    // Класс для тестовых данных с использованием ClassData
    public class CircleAreaTestData : IEnumerable<object[]>
    {
        public IEnumerator<object[]> GetEnumerator()
        {
            yield return new object[] { 1.0, Math.PI };
            yield return new object[] { 2.0, 4 * Math.PI };
            yield return new object[] { 5.0, 25 * Math.PI };
            yield return new object[] { 10.0, 100 * Math.PI };
        }

        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() => GetEnumerator();
    }

    public class MathCalculatorAreaTests
    {
        private readonly MathCalculator _calculator = new MathCalculator();

        [Theory]
        [ClassData(typeof(CircleAreaTestData))]
        public void CalculateCircleArea_ValidRadius_ReturnsCorrectArea(double radius, double expected)
        {
            // Act
            double result = _calculator.CalculateCircleArea(radius);

            // Assert
            Assert.Equal(expected, result, 5); // precision: 5 decimal places
        }
    }
}
```

---

## **Варианты заданий**

**Вариант 1:** Класс `StringUtilities`
- `bool IsPalindrome(string text)`
- `string ReverseString(string input)`
- `int CountVowels(string text)`

**Вариант 2:** Класс `DateValidator`
- `bool IsLeapYear(int year)`
- `bool IsValidDate(int year, int month, int day)`
- `string GetSeason(int month)`

**Вариант 3:** Класс `GeometryCalculator`
- `double CalculateTriangleArea(double a, double b, double c)`
- `bool IsRightTriangle(double a, double b, double c)`
- `double CalculateCircleCircumference(double radius)`

**Вариант 4:** Класс `NumberConverter`
- `string DecimalToBinary(int number)`
- `string DecimalToRoman(int number)`
- `int RomanToDecimal(string roman)`

**Вариант 5:** Класс `PasswordValidator`
- `bool IsStrongPassword(string password)`
- `int GetPasswordScore(string password)`
- `bool MeetsLengthRequirement(string password, int minLength)`

**Вариант 6:** Класс `EmailProcessor`
- `bool IsValidEmail(string email)`
- `string ExtractDomain(string email)`
- `string ExtractUsername(string email)`

**Вариант 7:** Класс `ArrayOperations`
- `int FindMax(int[] array)`
- `int[] SortArray(int[] array)`
- `bool ContainsDuplicates(int[] array)`

**Вариант 8:** Класс `MathFunctions`
- `int Factorial(int n)`
- `int Fibonacci(int n)`
- `bool IsPerfectNumber(int number)`

**Вариант 9:** Класс `TextFormatter`
- `string CapitalizeWords(string text)`
- `string RemoveExtraSpaces(string text)`
- `string[] SplitIntoSentences(string text)`

**Вариант 10:** Класс `BankAccountCalculator`
- `decimal CalculateInterest(decimal principal, double rate, int years)`
- `decimal CalculateMonthlyPayment(decimal loanAmount, double annualRate, int years)`
- `bool CanAffordLoan(decimal income, decimal monthlyPayment)`

**Вариант 11:** Класс `ColorConverter`
- `string RgbToHex(int r, int g, int b)`
- `string HexToRgb(string hex)`
- `bool IsValidHexColor(string hex)`

**Вариант 12:** Класс `UnitConverter`
- `double CelsiusToFahrenheit(double celsius)`
- `double KilometersToMiles(double kilometers)`
- `double KilogramsToPounds(double kilograms)`

**Вариант 13:** Класс `StringAnalyzer`
- `int CountWords(string text)`
- `int CountSentences(string text)`
- `Dictionary<char, int> GetCharacterFrequency(string text)`

**Вариант 14:** Класс `PrimeNumberGenerator`
- `bool IsPrime(int number)`
- `int[] GetPrimesInRange(int start, int end)`
- `int FindNextPrime(int number)`

**Вариант 15:** Класс `ShapeCalculator`
- `double CalculateRectangleArea(double width, double height)`
- `double CalculateCubeVolume(double side)`
- `double CalculateSphereVolume(double radius)`

---

## **Критерии оценки**

**5 (Отлично):**
- Реализованы все методы согласно варианту
- Созданы параметризированные тесты с использованием всех трех способов:
  - `[InlineData]` для простых случаев (минимум 4 набора данных)
  - `[MemberData]` для средних наборов (минимум 6 наборов данных)
  - `[ClassData]` для сложных структур (минимум 4 набора данных)
- Тесты покрывают основные, граничные и ошибочные сценарии
- Все тесты проходят, код хорошо организован

**4 (Хорошо):**
- Реализованы основные методы
- Использованы 2 из 3 способов параметризации
- Тесты покрывают основные сценарии
- Все тесты проходят

**3 (Удовлетворительно):**
- Реализована часть методов
- Использован только `[InlineData]` для параметризации
- Тесты покрывают только основные сценарии
- Возможны незначительные ошибки

**2 (Неудовлетворительно):**
- Методы не реализованы или реализованы некорректно
- Параметризированные тесты не написаны
- Тесты не компилируются или не проходят

---

## **Контрольные вопросы**

1. В чем преимущество параметризированных тестов перед обычными?
2. Какая разница между атрибутами `[Fact]` и `[Theory]`?
3. Когда следует использовать `[InlineData]`, `[MemberData]` и `[ClassData]`?
4. Как организовать тестовые данные для сложных объектов?
5. Можно ли комбинировать разные способы подачи данных в одном тестовом методе?
6. Как обрабатывать исключения в параметризированных тестах?
7. Какие ограничения есть у атрибута `[InlineData]`?

---

## **Пример README.md для варианта 1**

```markdown
# Практическая работа: Написание параметризированных тестов

**Вариант: 1**

**Задание:**
Реализовать класс `StringUtilities` с методами:
- `bool IsPalindrome(string text)` - проверяет, является ли строка палиндромом
- `string ReverseString(string input)` - возвращает перевернутую строку  
- `int CountVowels(string text)` - подсчитывает количество гласных букв

Написать параметризированные тесты, используя InlineData, MemberData и ClassData.

**Код реализации:**

```csharp
// ParametrizedTestsDemo/StringUtilities.cs
using System;
using System.Linq;

namespace ParametrizedTestsDemo
{
    public class StringUtilities
    {
        public bool IsPalindrome(string text)
        {
            if (string.IsNullOrEmpty(text))
                return false;
                
            string clean = new string(text.ToLower().Where(char.IsLetterOrDigit).ToArray());
            return clean.SequenceEqual(clean.Reverse());
        }

        public string ReverseString(string input)
        {
            if (input == null)
                throw new ArgumentNullException(nameof(input));
                
            return new string(input.Reverse().ToArray());
        }

        public int CountVowels(string text)
        {
            if (string.IsNullOrEmpty(text))
                return 0;
                
            char[] vowels = { 'a', 'e', 'i', 'o', 'u', 'а', 'е', 'ё', 'и', 'о', 'у', 'ы', 'э', 'ю', 'я' };
            return text.ToLower().Count(c => vowels.Contains(c));
        }
    }
}
```

**Код тестов:**

```csharp
// ParametrizedTestsDemo.Tests/StringUtilitiesTests.cs
using Xunit;
using ParametrizedTestsDemo;

namespace ParametrizedTestsDemo.Tests
{
    public class StringUtilitiesTests
    {
        private readonly StringUtilities _utils = new StringUtilities();

        // Тестирование с InlineData
        [Theory]
        [InlineData("hello", "olleh")]
        [InlineData("123", "321")]
        [InlineData("a", "a")]
        [InlineData("", "")]
        public void ReverseString_VariousInputs_ReturnsReversed(string input, string expected)
        {
            // Act
            string result = _utils.ReverseString(input);

            // Assert
            Assert.Equal(expected, result);
        }

        [Theory]
        [InlineData(null)]
        public void ReverseString_NullInput_ThrowsException(string input)
        {
            // Act & Assert
            Assert.Throws<ArgumentNullException>(() => _utils.ReverseString(input));
        }

        // Тестирование с MemberData
        public static IEnumerable<object[]> PalindromeTestData =>
            new List<object[]>
            {
                new object[] { "racecar", true },
                new object[] { "A man a plan a canal Panama", true },
                new object[] { "hello", false },
                new object[] { "12321", true },
                new object[] { "", false },
                new object[] { "a", true }
            };

        [Theory]
        [MemberData(nameof(PalindromeTestData))]
        public void IsPalindrome_VariousInputs_ReturnsExpected(string input, bool expected)
        {
            // Act
            bool result = _utils.IsPalindrome(input);

            // Assert
            Assert.Equal(expected, result);
        }

        // Тестирование с MemberData для сложных случаев
        public static IEnumerable<object[]> VowelCountTestData =>
            new List<object[]>
            {
                new object[] { "hello", 2 },
                new object[] { "AEIOU", 5 },
                new object[] { "bcdfg", 0 },
                new object[] { "Hello World", 3 },
                new object[] { "Привет", 2 },
                new object[] { "", 0 },
                new object[] { "12345", 0 }
            };

        [Theory]
        [MemberData(nameof(VowelCountTestData))]
        public void CountVowels_VariousInputs_ReturnsCorrectCount(string input, int expected)
        {
            // Act
            int result = _utils.CountVowels(input);

            // Assert
            Assert.Equal(expected, result);
        }
    }

    // Класс для тестовых данных с использованием ClassData
    public class ComplexPalindromeTestData : IEnumerable<object[]>
    {
        public IEnumerator<object[]> GetEnumerator()
        {
            yield return new object[] { "Madam", true };
            yield return new object[] { "Was it a car or a cat I saw?", true };
            yield return new object[] { "No 'x' in Nixon", true };
            yield return new object[] { "Regular string", false };
            yield return new object[] { "A", true };
        }

        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() => GetEnumerator();
    }

    public class StringUtilitiesComplexTests
    {
        private readonly StringUtilities _utils = new StringUtilities();

        [Theory]
        [ClassData(typeof(ComplexPalindromeTestData))]
        public void IsPalindrome_ComplexCases_ReturnsExpected(string input, bool expected)
        {
            // Act
            bool result = _utils.IsPalindrome(input);

            // Assert
            Assert.Equal(expected, result);
        }
    }
}
```

**Результат выполнения тестов:**
![Скриншот тестов](images/test_results.png)
```