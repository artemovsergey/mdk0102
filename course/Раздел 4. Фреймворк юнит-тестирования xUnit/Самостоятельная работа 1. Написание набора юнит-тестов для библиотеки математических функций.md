# Самостоятельная работа 1. Написание набора юнит-тестов для библиотеки математических функций

## **Тема**
Комплексное тестирование библиотеки математических функций с использованием различных техник xUnit.

## **Цель**
Закрепить на практике полученные знания по написанию юнит-тестов:
- Создание тестового проекта и организация структуры
- Использование различных методов Assert
- Написание параметризированных тестов
- Тестирование исключительных ситуаций
- Организация тестов с помощью Trait атрибутов
- Работа с фикстурами данных

## **Ход работы**

### **1. Создание структуры проекта**

Создайте решение с следующими проектами:
- **MathLibrary** - библиотека математических функций
- **MathLibrary.Tests** - проект с юнит-тестами

### **2. Реализация математической библиотеки**

**MathLibrary/MathOperations.cs:**
```csharp
using System;

namespace MathLibrary
{
    public class MathOperations
    {
        public int Add(int a, int b) => a + b;
        
        public int Subtract(int a, int b) => a - b;
        
        public int Multiply(int a, int b) => a * b;
        
        public double Divide(int a, int b)
        {
            if (b == 0)
                throw new DivideByZeroException("Division by zero is not allowed.");
            return (double)a / b;
        }
        
        public int Power(int baseNum, int exponent)
        {
            if (exponent < 0)
                throw new ArgumentException("Exponent cannot be negative.", nameof(exponent));
                
            if (exponent == 0) return 1;
            
            int result = 1;
            for (int i = 0; i < exponent; i++)
            {
                result *= baseNum;
            }
            return result;
        }
        
        public long Factorial(int n)
        {
            if (n < 0)
                throw new ArgumentException("Factorial is not defined for negative numbers.", nameof(n));
                
            if (n > 20)
                throw new OverflowException("Factorial of numbers greater than 20 causes overflow.");
                
            if (n == 0 || n == 1) return 1;
            
            long result = 1;
            for (int i = 2; i <= n; i++)
            {
                result *= i;
            }
            return result;
        }
        
        public bool IsPrime(int number)
        {
            if (number <= 1) return false;
            if (number == 2) return true;
            if (number % 2 == 0) return false;
            
            for (int i = 3; i <= Math.Sqrt(number); i += 2)
            {
                if (number % i == 0)
                    return false;
            }
            return true;
        }
        
        public int GCD(int a, int b)
        {
            a = Math.Abs(a);
            b = Math.Abs(b);
            
            while (b != 0)
            {
                int temp = b;
                b = a % b;
                a = temp;
            }
            return a;
        }
        
        public int LCM(int a, int b)
        {
            if (a == 0 || b == 0)
                return 0;
                
            return Math.Abs(a * b) / GCD(a, b);
        }
        
        public double SquareRoot(double number)
        {
            if (number < 0)
                throw new ArgumentException("Cannot calculate square root of negative number.", nameof(number));
                
            return Math.Sqrt(number);
        }
        
        public double CalculateCircleArea(double radius)
        {
            if (radius <= 0)
                throw new ArgumentException("Radius must be positive.", nameof(radius));
                
            return Math.PI * radius * radius;
        }
        
        public double CalculateTriangleArea(double a, double b, double c)
        {
            if (a <= 0 || b <= 0 || c <= 0)
                throw new ArgumentException("All sides must be positive.", nameof(a));
                
            if (a + b <= c || a + c <= b || b + c <= a)
                throw new ArgumentException("The sum of any two sides must be greater than the third side.");
                
            double s = (a + b + c) / 2;
            return Math.Sqrt(s * (s - a) * (s - b) * (s - c));
        }
        
        public bool IsRightTriangle(double a, double b, double c)
        {
            if (a <= 0 || b <= 0 || c <= 0)
                return false;
                
            double[] sides = { a, b, c };
            Array.Sort(sides);
            
            return Math.Abs(Math.Pow(sides[0], 2) + Math.Pow(sides[1], 2) - Math.Pow(sides[2], 2)) < 0.0001;
        }
    }
}
```

**MathLibrary/Statistics.cs:**
```csharp
using System;
using System.Collections.Generic;
using System.Linq;

namespace MathLibrary
{
    public class Statistics
    {
        public double CalculateMean(int[] numbers)
        {
            if (numbers == null || numbers.Length == 0)
                throw new ArgumentException("Array cannot be null or empty.", nameof(numbers));
                
            return numbers.Average();
        }
        
        public double CalculateMedian(int[] numbers)
        {
            if (numbers == null || numbers.Length == 0)
                throw new ArgumentException("Array cannot be null or empty.", nameof(numbers));
                
            var sorted = numbers.OrderBy(n => n).ToArray();
            int mid = sorted.Length / 2;
            
            if (sorted.Length % 2 == 0)
                return (sorted[mid - 1] + sorted[mid]) / 2.0;
            else
                return sorted[mid];
        }
        
        public int CalculateMode(int[] numbers)
        {
            if (numbers == null || numbers.Length == 0)
                throw new ArgumentException("Array cannot be null or empty.", nameof(numbers));
                
            var groups = numbers.GroupBy(n => n);
            int maxCount = groups.Max(g => g.Count());
            return groups.First(g => g.Count() == maxCount).Key;
        }
        
        public double CalculateStandardDeviation(int[] numbers)
        {
            if (numbers == null || numbers.Length < 2)
                throw new ArgumentException("Array must contain at least 2 elements.", nameof(numbers));
                
            double mean = CalculateMean(numbers);
            double sumOfSquares = numbers.Sum(n => Math.Pow(n - mean, 2));
            return Math.Sqrt(sumOfSquares / (numbers.Length - 1));
        }
        
        public int FindMax(int[] numbers)
        {
            if (numbers == null || numbers.Length == 0)
                throw new ArgumentException("Array cannot be null or empty.", nameof(numbers));
                
            return numbers.Max();
        }
        
        public int FindMin(int[] numbers)
        {
            if (numbers == null || numbers.Length == 0)
                throw new ArgumentException("Array cannot be null or empty.", nameof(numbers));
                
            return numbers.Min();
        }
        
        public int CalculateSum(int[] numbers)
        {
            if (numbers == null)
                throw new ArgumentNullException(nameof(numbers));
                
            return numbers.Sum();
        }
    }
}
```

### **3. Организация тестовых данных и фикстур**

**MathLibrary.Tests/TestTraits.cs:**
```csharp
namespace MathLibrary.Tests
{
    public static class TestTraits
    {
        public const string Category = "Category";
        public const string Priority = "Priority";
        public const string Feature = "Feature";
        public const string Type = "Type";
        
        public static class Categories
        {
            public const string Unit = "Unit";
            public const string Integration = "Integration";
            public const string Smoke = "Smoke";
            public const string Performance = "Performance";
        }
        
        public static class Priorities
        {
            public const string Critical = "Critical";
            public const string High = "High";
            public const string Medium = "Medium";
            public const string Low = "Low";
        }
        
        public static class Features
        {
            public const string BasicOperations = "BasicOperations";
            public const string AdvancedMath = "AdvancedMath";
            public const string Geometry = "Geometry";
            public const string Statistics = "Statistics";
        }
        
        public static class Types
        {
            public const string Positive = "Positive";
            public const string Negative = "Negative";
            public const string Boundary = "Boundary";
            public const string Exception = "Exception";
        }
    }
}
```

**MathLibrary.Tests/MathTestFixture.cs:**
```csharp
using Xunit;

namespace MathLibrary.Tests
{
    public class MathTestFixture
    {
        public MathOperations MathOps { get; }
        public Statistics Stats { get; }
        
        public MathTestFixture()
        {
            MathOps = new MathOperations();
            Stats = new Statistics();
        }
    }
    
    public class TestDataFixture
    {
        public int[] PrimeNumbers => new[] { 2, 3, 5, 7, 11, 13, 17, 19 };
        public int[] FibonacciSequence => new[] { 0, 1, 1, 2, 3, 5, 8, 13, 21 };
        public int[] TestArray => new[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
        public int[] EmptyArray => new int[0];
        public int[] SingleElementArray => new[] { 42 };
    }
    
    [CollectionDefinition("MathTestCollection")]
    public class MathTestCollection : ICollectionFixture<MathTestFixture>
    {
    }
}
```

### **4. Написание комплексных тестов**

**MathLibrary.Tests/BasicOperationsTests.cs:**
```csharp
using Xunit;
using MathLibrary;

namespace MathLibrary.Tests
{
    [Trait(TestTraits.Category, TestTraits.Categories.Unit)]
    [Trait(TestTraits.Feature, TestTraits.Features.BasicOperations)]
    public class BasicOperationsTests : IClassFixture<MathTestFixture>
    {
        private readonly MathTestFixture _fixture;
        
        public BasicOperationsTests(MathTestFixture fixture)
        {
            _fixture = fixture;
        }
        
        [Trait(TestTraits.Priority, TestTraits.Priorities.Critical)]
        [Trait(TestTraits.Type, TestTraits.Types.Positive)]
        [Theory]
        [InlineData(2, 3, 5)]
        [InlineData(0, 0, 0)]
        [InlineData(-5, 10, 5)]
        [InlineData(int.MaxValue, 0, int.MaxValue)]
        public void Add_VariousNumbers_ReturnsCorrectSum(int a, int b, int expected)
        {
            // Act
            int result = _fixture.MathOps.Add(a, b);
            
            // Assert
            Assert.Equal(expected, result);
        }
        
        [Trait(TestTraits.Priority, TestTraits.Priorities.High)]
        [Trait(TestTraits.Type, TestTraits.Types.Positive)]
        [Theory]
        [InlineData(10, 4, 6)]
        [InlineData(0, 5, -5)]
        [InlineData(-5, -3, -2)]
        [InlineData(int.MinValue, 0, int.MinValue)]
        public void Subtract_VariousNumbers_ReturnsCorrectDifference(int a, int b, int expected)
        {
            // Act
            int result = _fixture.MathOps.Subtract(a, b);
            
            // Assert
            Assert.Equal(expected, result);
        }
        
        [Trait(TestTraits.Priority, TestTraits.Priorities.High)]
        [Trait(TestTraits.Type, TestTraits.Types.Positive)]
        [Theory]
        [InlineData(3, 4, 12)]
        [InlineData(0, 100, 0)]
        [InlineData(-5, 6, -30)]
        [InlineData(-4, -5, 20)]
        public void Multiply_VariousNumbers_ReturnsCorrectProduct(int a, int b, int expected)
        {
            // Act
            int result = _fixture.MathOps.Multiply(a, b);
            
            // Assert
            Assert.Equal(expected, result);
        }
        
        [Trait(TestTraits.Priority, TestTraits.Priorities.Critical)]
        [Trait(TestTraits.Type, TestTraits.Types.Positive)]
        [Theory]
        [InlineData(10, 2, 5.0)]
        [InlineData(9, 4, 2.25)]
        [InlineData(0, 5, 0.0)]
        [InlineData(-10, 2, -5.0)]
        public void Divide_ValidNumbers_ReturnsCorrectQuotient(int a, int b, double expected)
        {
            // Act
            double result = _fixture.MathOps.Divide(a, b);
            
            // Assert
            Assert.Equal(expected, result, 5);
        }
        
        [Trait(TestTraits.Priority, TestTraits.Priorities.Critical)]
        [Trait(TestTraits.Type, TestTraits.Types.Exception)]
        [Fact]
        public void Divide_ByZero_ThrowsDivideByZeroException()
        {
            // Act & Assert
            var exception = Assert.Throws<DivideByZeroException>(() => 
                _fixture.MathOps.Divide(10, 0));
                
            Assert.Contains("Division by zero", exception.Message);
        }
    }
}
```

**MathLibrary.Tests/AdvancedMathTests.cs:**
```csharp
using Xunit;
using MathLibrary;

namespace MathLibrary.Tests
{
    [Trait(TestTraits.Category, TestTraits.Categories.Unit)]
    [Trait(TestTraits.Feature, TestTraits.Features.AdvancedMath)]
    public class AdvancedMathTests : IClassFixture<MathTestFixture>
    {
        private readonly MathTestFixture _fixture;
        
        public AdvancedMathTests(MathTestFixture fixture)
        {
            _fixture = fixture;
        }
        
        public static IEnumerable<object[]> PowerTestData =>
            new List<object[]>
            {
                new object[] { 2, 3, 8 },
                new object[] { 5, 0, 1 },
                new object[] { 10, 1, 10 },
                new object[] { 3, 4, 81 },
                new object[] { 1, 100, 1 }
            };
        
        [Trait(TestTraits.Priority, TestTraits.Priorities.High)]
        [Trait(TestTraits.Type, TestTraits.Types.Positive)]
        [Theory]
        [MemberData(nameof(PowerTestData))]
        public void Power_ValidInput_ReturnsCorrectResult(int baseNum, int exponent, int expected)
        {
            // Act
            int result = _fixture.MathOps.Power(baseNum, exponent);
            
            // Assert
            Assert.Equal(expected, result);
        }
        
        [Trait(TestTraits.Priority, TestTraits.Priorities.Medium)]
        [Trait(TestTraits.Type, TestTraits.Types.Exception)]
        [Theory]
        [InlineData(-1)]
        [InlineData(-10)]
        public void Power_NegativeExponent_ThrowsArgumentException(int exponent)
        {
            // Act & Assert
            var exception = Assert.Throws<ArgumentException>(() => 
                _fixture.MathOps.Power(2, exponent));
                
            Assert.Equal("exponent", exception.ParamName);
        }
        
        public static IEnumerable<object[]> FactorialTestData =>
            new List<object[]>
            {
                new object[] { 0, 1L },
                new object[] { 1, 1L },
                new object[] { 5, 120L },
                new object[] { 10, 3628800L },
                new object[] { 20, 2432902008176640000L }
            };
        
        [Trait(TestTraits.Priority, TestTraits.Priorities.High)]
        [Trait(TestTraits.Type, TestTraits.Types.Positive)]
        [Theory]
        [MemberData(nameof(FactorialTestData))]
        public void Factorial_ValidInput_ReturnsCorrectResult(int n, long expected)
        {
            // Act
            long result = _fixture.MathOps.Factorial(n);
            
            // Assert
            Assert.Equal(expected, result);
        }
        
        [Trait(TestTraits.Priority, TestTraits.Priorities.Medium)]
        [Trait(TestTraits.Type, TestTraits.Types.Exception)]
        [Theory]
        [InlineData(-1)]
        [InlineData(-5)]
        public void Factorial_NegativeNumber_ThrowsArgumentException(int n)
        {
            // Act & Assert
            var exception = Assert.Throws<ArgumentException>(() => 
                _fixture.MathOps.Factorial(n));
                
            Assert.Equal("n", exception.ParamName);
        }
        
        [Trait(TestTraits.Priority, TestTraits.Priorities.Medium)]
        [Trait(TestTraits.Type, TestTraits.Types.Exception)]
        [Theory]
        [InlineData(21)]
        [InlineData(100)]
        public void Factorial_LargeNumber_ThrowsOverflowException(int n)
        {
            // Act & Assert
            Assert.Throws<OverflowException>(() => _fixture.MathOps.Factorial(n));
        }
        
        public static IEnumerable<object[]> PrimeTestData =>
            new List<object[]>
            {
                new object[] { 2, true },
                new object[] { 3, true },
                new object[] { 4, false },
                new object[] { 17, true },
                new object[] { 1, false },
                new object[] { 0, false },
                new object[] { -5, false }
            };
        
        [Trait(TestTraits.Priority, TestTraits.Priorities.Medium)]
        [Trait(TestTraits.Type, TestTraits.Types.Positive)]
        [Theory]
        [MemberData(nameof(PrimeTestData))]
        public void IsPrime_VariousNumbers_ReturnsCorrectResult(int number, bool expected)
        {
            // Act
            bool result = _fixture.MathOps.IsPrime(number);
            
            // Assert
            Assert.Equal(expected, result);
        }
        
        public static IEnumerable<object[]> GCDTestData =>
            new List<object[]>
            {
                new object[] { 48, 18, 6 },
                new object[] { 0, 5, 5 },
                new object[] { 17, 13, 1 },
                new object[] { -24, 18, 6 },
                new object[] { 0, 0, 0 }
            };
        
        [Trait(TestTraits.Priority, TestTraits.Priorities.Medium)]
        [Trait(TestTraits.Type, TestTraits.Types.Positive)]
        [Theory]
        [MemberData(nameof(GCDTestData))]
        public void GCD_VariousNumbers_ReturnsCorrectResult(int a, int b, int expected)
        {
            // Act
            int result = _fixture.MathOps.GCD(a, b);
            
            // Assert
            Assert.Equal(expected, result);
        }
        
        public static IEnumerable<object[]> LCMTestData =>
            new List<object[]>
            {
                new object[] { 4, 6, 12 },
                new object[] { 5, 7, 35 },
                new object[] { 0, 5, 0 },
                new object[] { 12, 18, 36 }
            };
        
        [Trait(TestTraits.Priority, TestTraits.Priorities.Medium)]
        [Trait(TestTraits.Type, TestTraits.Types.Positive)]
        [Theory]
        [MemberData(nameof(LCMTestData))]
        public void LCM_VariousNumbers_ReturnsCorrectResult(int a, int b, int expected)
        {
            // Act
            int result = _fixture.MathOps.LCM(a, b);
            
            // Assert
            Assert.Equal(expected, result);
        }
    }
}
```

**MathLibrary.Tests/GeometryTests.cs:**
```csharp
using Xunit;
using MathLibrary;

namespace MathLibrary.Tests
{
    [Trait(TestTraits.Category, TestTraits.Categories.Unit)]
    [Trait(TestTraits.Feature, TestTraits.Features.Geometry)]
    public class GeometryTests : IClassFixture<MathTestFixture>
    {
        private readonly MathTestFixture _fixture;
        
        public GeometryTests(MathTestFixture fixture)
        {
            _fixture = fixture;
        }
        
        [Trait(TestTraits.Priority, TestTraits.Priorities.High)]
        [Trait(TestTraits.Type, TestTraits.Types.Positive)]
        [Theory]
        [InlineData(1.0, Math.PI)]
        [InlineData(2.0, 4 * Math.PI)]
        [InlineData(5.0, 25 * Math.PI)]
        public void CalculateCircleArea_ValidRadius_ReturnsCorrectArea(double radius, double expected)
        {
            // Act
            double result = _fixture.MathOps.CalculateCircleArea(radius);
            
            // Assert
            Assert.Equal(expected, result, 5);
        }
        
        [Trait(TestTraits.Priority, TestTraits.Priorities.Medium)]
        [Trait(TestTraits.Type, TestTraits.Types.Exception)]
        [Theory]
        [InlineData(0)]
        [InlineData(-1)]
        [InlineData(-5.5)]
        public void CalculateCircleArea_InvalidRadius_ThrowsArgumentException(double radius)
        {
            // Act & Assert
            var exception = Assert.Throws<ArgumentException>(() => 
                _fixture.MathOps.CalculateCircleArea(radius));
                
            Assert.Equal("radius", exception.ParamName);
        }
        
        [Trait(TestTraits.Priority, TestTraits.Priorities.High)]
        [Trait(TestTraits.Type, TestTraits.Types.Positive)]
        [Theory]
        [InlineData(3, 4, 5, 6.0)]
        [InlineData(5, 12, 13, 30.0)]
        [InlineData(6, 8, 10, 24.0)]
        public void CalculateTriangleArea_ValidSides_ReturnsCorrectArea(double a, double b, double c, double expected)
        {
            // Act
            double result = _fixture.MathOps.CalculateTriangleArea(a, b, c);
            
            // Assert
            Assert.Equal(expected, result, 5);
        }
        
        [Trait(TestTraits.Priority, TestTraits.Priorities.Medium)]
        [Trait(TestTraits.Type, TestTraits.Types.Exception)]
        [Theory]
        [InlineData(0, 4, 5)]
        [InlineData(3, -1, 5)]
        [InlineData(1, 2, 3)] // Invalid triangle
        [InlineData(1, 1, 3)] // Invalid triangle
        public void CalculateTriangleArea_InvalidSides_ThrowsArgumentException(double a, double b, double c)
        {
            // Act & Assert
            Assert.Throws<ArgumentException>(() => 
                _fixture.MathOps.CalculateTriangleArea(a, b, c));
        }
        
        [Trait(TestTraits.Priority, TestTraits.Priorities.Medium)]
        [Trait(TestTraits.Type, TestTraits.Types.Positive)]
        [Theory]
        [InlineData(3, 4, 5, true)]
        [InlineData(5, 12, 13, true)]
        [InlineData(6, 8, 10, true)]
        [InlineData(2, 3, 4, false)]
        [InlineData(1, 1, 1, false)]
        public void IsRightTriangle_VariousTriangles_ReturnsCorrectResult(double a, double b, double c, bool expected)
        {
            // Act
            bool result = _fixture.MathOps.IsRightTriangle(a, b, c);
            
            // Assert
            Assert.Equal(expected, result);
        }
        
        [Trait(TestTraits.Priority, TestTraits.Priorities.High)]
        [Trait(TestTraits.Type, TestTraits.Types.Positive)]
        [Theory]
        [InlineData(4, 2.0)]
        [InlineData(9, 3.0)]
        [InlineData(2, 1.41421356237)]
        [InlineData(0, 0.0)]
        public void SquareRoot_ValidNumber_ReturnsCorrectResult(double number, double expected)
        {
            // Act
            double result = _fixture.MathOps.SquareRoot(number);
            
            // Assert
            Assert.Equal(expected, result, 5);
        }
        
        [Trait(TestTraits.Priority, TestTraits.Priorities.Medium)]
        [Trait(TestTraits.Type, TestTraits.Types.Exception)]
        [Theory]
        [InlineData(-1)]
        [InlineData(-10.5)]
        public void SquareRoot_NegativeNumber_ThrowsArgumentException(double number)
        {
            // Act & Assert
            var exception = Assert.Throws<ArgumentException>(() => 
                _fixture.MathOps.SquareRoot(number));
                
            Assert.Equal("number", exception.ParamName);
        }
    }
}
```

**MathLibrary.Tests/StatisticsTests.cs:**
```csharp
using Xunit;
using MathLibrary;

namespace MathLibrary.Tests
{
    [Trait(TestTraits.Category, TestTraits.Categories.Unit)]
    [Trait(TestTraits.Feature, TestTraits.Features.Statistics)]
    public class StatisticsTests : IClassFixture<MathTestFixture>
    {
        private readonly MathTestFixture _fixture;
        
        public StatisticsTests(MathTestFixture fixture)
        {
            _fixture = fixture;
        }
        
        [Trait(TestTraits.Priority, TestTraits.Priorities.Critical)]
        [Trait(TestTraits.Type, TestTraits.Types.Positive)]
        [Theory]
        [InlineData(new[] { 1, 2, 3, 4, 5 }, 3.0)]
        [InlineData(new[] { 10, 20, 30 }, 20.0)]
        [InlineData(new[] { -5, 0, 5 }, 0.0)]
        [InlineData(new[] { 42 }, 42.0)]
        public void CalculateMean_ValidArray_ReturnsCorrectMean(int[] numbers, double expected)
        {
            // Act
            double result = _fixture.Stats.CalculateMean(numbers);
            
            // Assert
            Assert.Equal(expected, result, 5);
        }
        
        [Trait(TestTraits.Priority, TestTraits.Priorities.High)]
        [Trait(TestTraits.Type, TestTraits.Types.Exception)]
        [Theory]
        [InlineData(null)]
        [InlineData(new int[0])]
        public void CalculateMean_InvalidArray_ThrowsArgumentException(int[] numbers)
        {
            // Act & Assert
            Assert.Throws<ArgumentException>(() => _fixture.Stats.CalculateMean(numbers));
        }
        
        [Trait(TestTraits.Priority, TestTraits.Priorities.High)]
        [Trait(TestTraits.Type, TestTraits.Types.Positive)]
        [Theory]
        [InlineData(new[] { 1, 2, 3, 4, 5 }, 3.0)]
        [InlineData(new[] { 1, 2, 3, 4 }, 2.5)]
        [InlineData(new[] { 10 }, 10.0)]
        [InlineData(new[] { 5, 1, 3, 2, 4 }, 3.0)] // Unsorted
        public void CalculateMedian_ValidArray_ReturnsCorrectMedian(int[] numbers, double expected)
        {
            // Act
            double result = _fixture.Stats.CalculateMedian(numbers);
            
            // Assert
            Assert.Equal(expected, result, 5);
        }
        
        [Trait(TestTraits.Priority, TestTraits.Priorities.Medium)]
        [Trait(TestTraits.Type, TestTraits.Types.Positive)]
        [Theory]
        [InlineData(new[] { 1, 2, 2, 3, 4 }, 2)]
        [InlineData(new[] { 1, 1, 2, 2, 3 }, 1)] // First mode
        [InlineData(new[] { 5 }, 5)]
        [InlineData(new[] { 1, 3, 3, 7, 7, 7 }, 7)]
        public void CalculateMode_ValidArray_ReturnsCorrectMode(int[] numbers, int expected)
        {
            // Act
            int result = _fixture.Stats.CalculateMode(numbers);
            
            // Assert
            Assert.Equal(expected, result);
        }
        
        [Trait(TestTraits.Priority, TestTraits.Priorities.Medium)]
        [Trait(TestTraits.Type, TestTraits.Types.Positive)]
        [Theory]
        [InlineData(new[] { 1, 2, 3, 4, 5 }, 1.58113883)]
        [InlineData(new[] { 10, 12, 23, 23, 16, 23, 21, 16 }, 5.237229365)]
        public void CalculateStandardDeviation_ValidArray_ReturnsCorrectValue(int[] numbers, double expected)
        {
            // Act
            double result = _fixture.Stats.CalculateStandardDeviation(numbers);
            
            // Assert
            Assert.Equal(expected, result, 5);
        }
        
        [Trait(TestTraits.Priority, TestTraits.Priorities.Medium)]
        [Trait(TestTraits.Type, TestTraits.Types.Exception)]
        [Theory]
        [InlineData(null)]
        [InlineData(new int[0])]
        [InlineData(new[] { 42 })]
        public void CalculateStandardDeviation_InvalidArray_ThrowsArgumentException(int[] numbers)
        {
            // Act & Assert
            Assert.Throws<ArgumentException>(() => _fixture.Stats.CalculateStandardDeviation(numbers));
        }
        
        [Trait(TestTraits.Priority, TestTraits.Priorities.High)]
        [Trait(TestTraits.Type, TestTraits.Types.Positive)]
        [Theory]
        [InlineData(new[] { 1, 2, 3, 4, 5 }, 5)]
        [InlineData(new[] { -5, -1, -10 }, -1)]
        [InlineData(new[] { 0 }, 0)]
        [InlineData(new[] { 10, 10, 10 }, 10)]
        public void FindMax_ValidArray_ReturnsMaximumValue(int[] numbers, int expected)
        {
            // Act
            int result = _fixture.Stats.FindMax(numbers);
            
            // Assert
            Assert.Equal(expected, result);
        }
        
        [Trait(TestTraits.Priority, TestTraits.Priorities.High)]
        [Trait(TestTraits.Type, TestTraits.Types.Positive)]
        [Theory]
        [InlineData(new[] { 1, 2, 3, 4, 5 }, 1)]
        [InlineData(new[] { -5, -1, -10 }, -10)]
        [InlineData(new[] { 0 }, 0)]
        [InlineData(new[] { 10, 10, 10 }, 10)]
        public void FindMin_ValidArray_ReturnsMinimumValue(int[] numbers, int expected)
        {
            // Act
            int result = _fixture.Stats.FindMin(numbers);
            
            // Assert
            Assert.Equal(expected, result);
        }
        
        [Trait(TestTraits.Priority, TestTraits.Priorities.Medium)]
        [Trait(TestTraits.Type, TestTraits.Types.Positive)]
        [Theory]
        [InlineData(new[] { 1, 2, 3, 4, 5 }, 15)]
        [InlineData(new[] { -1, 1 }, 0)]
        [InlineData(new[] { 10 }, 10)]
        [InlineData(new int[0], 0)]
        public void CalculateSum_ValidArray_ReturnsCorrectSum(int[] numbers, int expected)
        {
            // Act
            int result = _fixture.Stats.CalculateSum(numbers);
            
            // Assert
            Assert.Equal(expected, result);
        }
        
        [Trait(TestTraits.Priority, TestTraits.Priorities.Medium)]
        [Trait(TestTraits.Type, TestTraits.Types.Exception)]
        [Fact]
        public void CalculateSum_NullArray_ThrowsArgumentNullException()
        {
            // Act & Assert
            Assert.Throws<ArgumentNullException>(() => _fixture.Stats.CalculateSum(null));
        }
    }
}
```

**MathLibrary.Tests/SmokeTests.cs:**
```csharp
using Xunit;
using MathLibrary;

namespace MathLibrary.Tests
{
    [Trait(TestTraits.Category, TestTraits.Categories.Smoke)]
    public class SmokeTests
    {
        [Trait(TestTraits.Priority, TestTraits.Priorities.Critical)]
        [Trait(TestTraits.Feature, TestTraits.Features.BasicOperations)]
        [Fact]
        public void Smoke_BasicOperations_ShouldWork()
        {
            // Arrange
            var mathOps = new MathOperations();
            
            // Act & Assert - проверка что основные операции работают
            Assert.Equal(5, mathOps.Add(2, 3));
            Assert.Equal(1, mathOps.Subtract(4, 3));
            Assert.Equal(6, mathOps.Multiply(2, 3));
            Assert.Equal(2.5, mathOps.Divide(5, 2), 5);
        }
        
        [Trait(TestTraits.Priority, TestTraits.Priorities.Critical)]
        [Trait(TestTraits.Feature, TestTraits.Features.AdvancedMath)]
        [Fact]
        public void Smoke_AdvancedMath_ShouldWork()
        {
            // Arrange
            var mathOps = new MathOperations();
            
            // Act & Assert
            Assert.Equal(8, mathOps.Power(2, 3));
            Assert.Equal(120, mathOps.Factorial(5));
            Assert.True(mathOps.IsPrime(7));
        }
        
        [Trait(TestTraits.Priority, TestTraits.Priorities.Critical)]
        [Trait(TestTraits.Feature, TestTraits.Features.Statistics)]
        [Fact]
        public void Smoke_Statistics_ShouldWork()
        {
            // Arrange
            var stats = new Statistics();
            var numbers = new[] { 1, 2, 3, 4, 5 };
            
            // Act & Assert
            Assert.Equal(3.0, stats.CalculateMean(numbers), 5);
            Assert.Equal(3.0, stats.CalculateMedian(numbers), 5);
            Assert.Equal(1, stats.CalculateMode(new[] { 1, 1, 2, 3 }));
        }
    }
}
```

### **5. Критерии оценки**

**5 (Отлично):**
- Реализована полная математическая библиотека со всеми методами
- Созданы комплексные тесты для всех методов
- Использованы все изученные техники: различные Assert, параметризация, тестирование исключений, Trait атрибуты, фикстуры
- Тесты покрывают все сценарии: положительные, отрицательные, граничные
- Организована хорошая структура тестовых классов
- Все тесты проходят
- Созданы smoke-тесты для быстрой проверки

**4 (Хорошо):**
- Реализована основная функциональность библиотеки
- Созданы тесты для большинства методов
- Использованы основные техники тестирования
- Тесты покрывают основные сценарии
- Все тесты проходят

**3 (Удовлетворительно):**
- Реализована часть функциональности
- Созданы базовые тесты
- Использованы только простые техники тестирования
- Возможны незначительные ошибки

**2 (Неудовлетворительно):**
- Функциональность не реализована
- Тесты не написаны или не работают
- Не соблюдены требования к организации

### **6. Контрольные вопросы**

1. Какие преимущества дает использование параметризированных тестов для математических функций?
2. Как правильно организовать тестирование исключительных ситуаций?
3. В чем польза использования Trait атрибутов для организации тестов?
4. Когда следует использовать Class Fixture вместо создания экземпляров в каждом тесте?
5. Какие граничные случаи важно покрыть при тестировании математических функций?
6. Как обеспечить изоляцию тестов при использовании общих фикстур?
7. Какие метрики можно использовать для оценки качества тестового покрытия?

---

**Результат выполнения:**
Создайте папку `images` со скриншотом Test Explorer, показывающим все успешно выполненные тесты, организованные по категориям с помощью Trait атрибутов.