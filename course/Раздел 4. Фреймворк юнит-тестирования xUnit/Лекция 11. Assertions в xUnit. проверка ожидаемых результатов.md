# Лекция 11. Assertions в xUnit. Проверка ожидаемых результатов

**Цель:** Глубоко понять систему утверждений (assertions) в xUnit, научиться правильно формулировать проверки и освоить лучшие практики валидации тестовых результатов.

---

### **План лекции**

1.  **Философия Assertions: что мы на самом деле проверяем?**
2.  **Базовые утверждения: равенство, истинность, null-проверки**
3.  **Проверки исключений: валидация ошибочных сценариев**
4.  **Работа с коллекциями и сложными объектами**
5.  **Кастомизация проверок: создание понятных сообщений об ошибках**
6.  **Лучшие практики и антипаттерны в assertions**

---

### **Подробное рассмотрение каждого пункта плана**

#### **1. Философия Assertions: что мы на самом деле проверяем?**

**Подробное объяснение:**

Assertion (утверждение) — это проверка, которая определяет, соответствует ли фактический результат работы тестируемого кода ожидаемому результату. Если утверждение не выполняется, тест считается проваленным.

**Триада AAA (Arrange-Act-Assert):**
- **Arrange (Подготовка):** Настройка тестовых данных и окружения
- **Act (Действие):** Выполнение тестируемого метода
- **Assert (Проверка):** Валидация результата

**Роль тестировщика в assertions:**
```csharp
// Пример: тестировщик думает не только о "счастливом пути"
[Fact]
public void ProcessOrder_ValidOrder_ReturnsSuccess()
{
    // Arrange: тестировщик готовит ВАЛИДНЫЕ данные
    var order = new Order { Id = 1, Total = 100.0m, Status = OrderStatus.Pending };
    var processor = new OrderProcessor();

    // Act
    var result = processor.ProcessOrder(order);

    // Assert: тестировщик проверяет ВСЕ аспекты успешного результата
    Assert.True(result.IsSuccess);        // Основной флаг успеха
    Assert.Equal(OrderStatus.Completed, order.Status); // Изменение состояния
    Assert.NotNull(result.ProcessedDate); // Побочный эффект
}
```

**Психология хорошего assertion:** Хороший тестировщик задает вопросы:
- "Что именно должен вернуть этот метод?"
- "Какие побочные эффекты должны произойти?"
- "Как система должна измениться после выполнения операции?"

---

#### **2. Базовые утверждения: равенство, истинность, null-проверки**

**Подробное объяснение:**

Это основа основ, которую должен знать каждый тестировщик.

**Assert.Equal / Assert.NotEqual - проверка равенства:**
```csharp
[Theory]
[InlineData(5, 2, 3)]       // 5 - 2 = 3
[InlineData(10, 1, 9)]      // 10 - 1 = 9
public void Subtract_TwoNumbers_ReturnsCorrectResult(int a, int b, int expected)
{
    // Arrange
    var calculator = new Calculator();

    // Act
    var result = calculator.Subtract(a, b);

    // Assert
    Assert.Equal(expected, result); // Проверка точного равенства
}

// Для чисел с плавающей точкой используем точность
[Fact]
public void Divide_Numbers_ReturnsWithPrecision()
{
    var calculator = new Calculator();
    var result = calculator.Divide(10, 3);
    
    Assert.Equal(3.333, result, 3); // 3 - количество знаков после запятой для сравнения
}
```

**Assert.True / Assert.False - булевы проверки:**
```csharp
[Fact]
public void IsAdult_Age18_ReturnsTrue()
{
    var validator = new AgeValidator();
    
    var result = validator.IsAdult(18);
    
    Assert.True(result); // Явно проверяем на true
}

[Fact]
public void IsValidEmail_InvalidFormat_ReturnsFalse()
{
    var validator = new EmailValidator();
    
    var result = validator.IsValid("invalid-email");
    
    Assert.False(result); // Явно проверяем на false
}
```

**Assert.Null / Assert.NotNull - проверки ссылок:**
```csharp
[Fact]
public void FindUser_ExistingUser_ReturnsUserObject()
{
    var repository = new UserRepository();
    
    var user = repository.FindUser(1);
    
    Assert.NotNull(user); // Объект должен существовать
    Assert.Equal("John", user.FirstName); // Дополнительная проверка свойств
}

[Fact]
public void FindUser_NonExistingUser_ReturnsNull()
{
    var repository = new UserRepository();
    
    var user = repository.FindUser(999);
    
    Assert.Null(user); // Ожидаем null для несуществующего пользователя
}
```

**Assert.Same / Assert.NotSame - проверка ссылочной идентичности:**
```csharp
[Fact]
public void GetInstance_Singleton_ReturnsSameInstance()
{
    var instance1 = Singleton.Instance;
    var instance2 = Singleton.Instance;
    
    Assert.Same(instance1, instance2); // Это один и тот же объект в памяти
}

[Fact]
public void CreateUser_Always_ReturnsNewInstance()
{
    var factory = new UserFactory();
    
    var user1 = factory.CreateUser();
    var user2 = factory.CreateUser();
    
    Assert.NotSame(user1, user2); // Это разные объекты
}
```

---

#### **3. Проверки исключений: валидация ошибочных сценариев**

**Подробное объяснение:**

Профессиональный тестировщик проверяет не только успешные сценарии, но и обработку ошибок.

**Assert.Throws\<T> - проверка конкретного исключения:**
```csharp
[Fact]
public void Divide_ByZero_ThrowsDivideByZeroException()
{
    var calculator = new Calculator();
    
    // Act & Assert в одном вызове
    var exception = Assert.Throws<DivideByZeroException>(() => calculator.Divide(10, 0));
    
    // Дополнительная проверка сообщения исключения
    Assert.Contains("divide by zero", exception.Message.ToLower());
}
```

**Assert.ThrowsAny\<T> - проверка исключения или его подтипа:**
```csharp
[Fact]
public void ProcessOrder_NullOrder_ThrowsArgumentException()
{
    var processor = new OrderProcessor();
    
    // ThrowsAny ловит ArgumentException, ArgumentNullException, etc.
    var exception = Assert.ThrowsAny<ArgumentException>(() => processor.ProcessOrder(null));
    
    Assert.Contains("order", exception.Message.ToLower());
}
```

**Record.Exception - более гибкая проверка исключений:**
```csharp
[Fact]
public void ValidateEmail_NullInput_ThrowsArgumentNullException()
{
    var validator = new EmailValidator();
    
    var exception = Record.Exception(() => validator.ValidateEmail(null));
    
    Assert.NotNull(exception); // Просто проверяем, что исключение было
    Assert.IsType<ArgumentNullException>(exception);
}
```

**Практический пример для тестировщика:**
```csharp
public class FileProcessorTests
{
    [Fact]
    public void ReadConfigFile_FileNotExists_ThrowsFileNotFoundException()
    {
        var processor = new FileProcessor();
        var nonExistentFile = "non_existent_config.xml";
        
        var exception = Assert.Throws<FileNotFoundException>(
            () => processor.ReadConfigFile(nonExistentFile));
            
        Assert.Contains(nonExistentFile, exception.Message);
    }
    
    [Fact]
    public void ParseConfig_InvalidXml_ThrowsXmlException()
    {
        var processor = new FileProcessor();
        var invalidXml = "<config><unclosed_tag></config>";
        
        Assert.Throws<System.Xml.XmlException>(
            () => processor.ParseConfig(invalidXml));
    }
}
```

---

#### **4. Работа с коллекциями и сложными объектами**

**Подробное объяснение:**

Тестировщики часто работают с наборами данных и сложными структурами.

**Assert.Collection - проверка элементов коллекции:**
```csharp
[Fact]
public void GetActiveUsers_ReturnsOnlyActiveUsers()
{
    var service = new UserService();
    
    var activeUsers = service.GetActiveUsers();
    
    // Проверяем КАЖДЫЙ элемент коллекции
    Assert.Collection(activeUsers,
        user => {
            Assert.Equal("Alice", user.Name);
            Assert.True(user.IsActive);
        },
        user => {
            Assert.Equal("Bob", user.Name);
            Assert.True(user.IsActive);
        }
    );
}
```

**Assert.All - проверка условия для всех элементов:**
```csharp
[Fact]
public void GetAllAdults_ReturnsOnlyUsersOver18()
{
    var service = new UserService();
    
    var adults = service.GetAllAdults();
    
    // Убеждаемся, что ВСЕ пользователи взрослые
    Assert.All(adults, user => Assert.True(user.Age >= 18));
    
    // Дополнительная проверка, что коллекция не пустая
    Assert.NotEmpty(adults);
}
```

**Assert.Contains / Assert.DoesNotContain - проверка наличия элементов:**
```csharp
[Fact]
public void SearchUsers_ByQuery_ReturnsMatchingUsers()
{
    var service = new UserService();
    
    var results = service.SearchUsers("Smith");
    
    Assert.Contains(results, user => user.LastName == "Smith");
    Assert.DoesNotContain(results, user => user.LastName == "Johnson");
}
```

**Assert.Equal для коллекций - проверка полного соответствия:**
```csharp
[Fact]
public void SortUsers_ByName_ReturnsCorrectOrder()
{
    var service = new UserService();
    var expectedOrder = new[] { "Alice", "Bob", "Charlie" };
    
    var sortedUsers = service.SortUsersByName();
    var actualNames = sortedUsers.Select(u => u.Name).ToArray();
    
    Assert.Equal(expectedOrder, actualNames); // Проверяем точное соответствие и порядок
}
```

**Работа со сложными объектами:**
```csharp
public class OrderValidationTests
{
    [Fact]
    public void CreateOrder_WithValidData_ReturnsCompleteOrder()
    {
        var service = new OrderService();
        var orderRequest = new OrderRequest 
        { 
            CustomerId = 1, 
            Items = new[] { new OrderItem { ProductId = 1, Quantity = 2 } } 
        };
        
        var order = service.CreateOrder(orderRequest);
        
        // Множественные проверки сложного объекта
        Assert.NotNull(order);
        Assert.Equal(1, order.CustomerId);
        Assert.Equal(OrderStatus.Created, order.Status);
        Assert.NotNull(order.OrderNumber);
        Assert.NotEmpty(order.Items);
        Assert.InRange(order.TotalAmount, 0, decimal.MaxValue); // Проверка диапазона
        Assert.IsType<DateTime>(order.CreatedAt); // Проверка типа
    }
}
```

---

#### **5. Кастомизация проверок: создание понятных сообщений об ошибках**

**Подробное объясшение:**

Хорошие сообщения об ошибках экономят время при анализе падающих тестов.

**Кастомные сообщения об ошибках:**
```csharp
[Fact]
public void CalculateTax_ComplexCalculation_ReturnsExpectedValue()
{
    var calculator = new TaxCalculator();
    var order = CreateComplexOrder();
    
    var expectedTax = 123.45m;
    var actualTax = calculator.CalculateTax(order);
    
    // Понятное сообщение при падении теста
    Assert.True(Math.Abs(expectedTax - actualTax) < 0.01m, 
        $"Налог рассчитан неверно. Ожидалось: {expectedTax}, Получено: {actualTax}. " +
        $"Заказ: {order.Id}, Пользователь: {order.CustomerId}");
}
```

**Использование Assert.Multiple для нескольких проверок:**
```csharp
[Fact]
public void CompleteOrder_ValidOrder_UpdatesAllProperties()
{
    var service = new OrderService();
    var order = CreateTestOrder();
    
    service.CompleteOrder(order);
    
    // Все проверки выполняются, даже если некоторые падают
    Assert.Multiple(() =>
    {
        Assert.Equal(OrderStatus.Completed, order.Status);
        Assert.NotNull(order.CompletedDate);
        Assert.True(order.IsPaid);
        Assert.InRange(order.CompletedDate.Value, DateTime.Now.AddMinutes(-1), DateTime.Now.AddMinutes(1));
    });
    // В отчете будут видны ВСЕ failed assertions, а не только первая
}
```

---

#### **6. Лучшие практики и антипаттерны в assertions**

**Лучшие практики:**

1. **Одна ответственность на тест:**
```csharp
// ХОРОШО: один тест - одна проверка
[Fact]
public void CreateUser_ValidData_SetsCreatedDate() { /* ... */ }

[Fact] 
public void CreateUser_ValidData_SetsDefaultRole() { /* ... */ }

// ПЛОХО: много проверок в одном тесте
[Fact]
public void CreateUser_ValidData_SetsAllProperties() { /* ... */ }
```

2. **Читаемые утверждения:**
```csharp
// ХОРОШО: понятные проверки
Assert.True(user.IsActive);
Assert.Equal(ExpectedStatus, actualStatus);

// ПЛОХО: сложная логика в assertions
Assert.True(user.Status == Status.Active || (user.Status == Status.Pending && user.CreatedDate > DateTime.Now.AddDays(-1)));
```

3. **Использование подходящих методов:**
```csharp
// Вместо
Assert.True(collection.Count() == 3);
// Лучше
Assert.Equal(3, collection.Count());

// Вместо
Assert.True(user != null);
// Лучше
Assert.NotNull(user);
```

**Антипаттерны:**

1. **Тесты без assertions (False Positive):**
```csharp
// ПЛОХО: тест всегда проходит
[Fact]
public void ProcessOrder_Always_CallsRepository()
{
    var repository = new Mock<IRepository>();
    var service = new OrderService(repository.Object);
    
    service.ProcessOrder(new Order()); // НЕТ ASSERT!
    
    // Надо добавить:
    // repository.Verify(r => r.Save(It.IsAny<Order>()), Times.Once);
}
```

2. **Слишком общие проверки:**
```csharp
// ПЛОХО: непонятно, что именно проверяем
Assert.NotNull(result);

// ЛУЧШЕ: конкретные проверки
Assert.NotNull(result.Data);
Assert.True(result.IsSuccess);
Assert.Null(result.ErrorMessage);
```

3. **Зависимость от внешних данных:**
```csharp
// ПЛОХО: тест хрупкий
Assert.Equal(DateTime.Now.Date, result.Date);

// ЛУЧШЕ: контролируемые данные
var testDate = new DateTime(2024, 1, 15);
Assert.Equal(testDate, result.Date);
```

---

### **Резюме**

1. **Assertions** — это основа автоматизированного тестирования, которая определяет успех или провал теста.
2. **xUnit предоставляет богатый набор** методов для различных типов проверок: от простых равенств до сложных валидаций коллекций.
3. **Проверка исключений** — критически важна для тестирования ошибочных сценариев.
4. **Качественные сообщения об ошибках** и использование `Assert.Multiple` значительно упрощают отладку.
5. **Следование лучшим практикам** делает тесты поддерживаемыми и надежными.

---

### **Контрольные вопросы**

1. **В чем разница между `Assert.Throws<T>` и `Assert.ThrowsAny<T>`? Приведите примеры использования каждого.**
2. **Как проверить, что коллекция содержит определенные элементы в определенном порядке?**
3. **Что такое `Assert.Multiple` и в каких случаях его следует использовать?**
4. **Как проверить, что число находится в определенном диапазоне?**
5. **Какие методы xUnit вы используете для проверки строк (содержание, начало/окончание)?**
6. **Как правильно тестировать методы, которые работают с числами с плавающей точкой?**
7. **Почему важно проверять не только успешные сценарии, но и исключительные ситуации?**
8. **Создайте тест для метода, который должен выбросить `ArgumentException` с конкретным сообщением при невалидных входных данных.**