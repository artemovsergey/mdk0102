# Практическая работа 9. Работа с фикстурами данных (Class Fixture, Collection Fixture)

## **Тема**
Освоение техники работы с фикстурами данных в xUnit для управления общими ресурсами и состояниями между тестами.

## **Цель**
Научить студентов эффективно использовать фикстуры для:
- Создания и очистки общих ресурсов
- Управления состоянием между тестами
- Уменьшения дублирования кода в тестах
- Оптимизации времени выполнения тестов

## **Теоретическая часть**

**Фикстуры (Fixtures)** в xUnit - это механизм для разделения общего контекста между тестами. Они помогают управлять дорогостоящими ресурсами и общими состояниями.

### **Типы фикстур в xUnit:**

**1. Class Fixture**
- Создается один раз для всего тестового класса
- Разделяется между всеми тестами в классе
- Идеально для ресурсов, которые дорого создавать

**2. Collection Fixture**
- Создается один раз для набора тестовых классов
- Разделяется между всеми тестами в коллекции
- Подходит для глобальных ресурсов

### **Интерфейсы для фикстур:**

**`IDisposable`** - для освобождения ресурсов
**`IAsyncLifetime`** - для асинхронной инициализации и очистки

## **Ход работы**

1. Создайте решение с двумя проектами:
   - **Проект приложения**: `FixtureDemo`
   - **Тестовый проект**: `FixtureDemo.Tests`

2. Реализуйте фикстуры согласно вашему варианту

3. Создайте тестовые классы с использованием Class Fixture и Collection Fixture

4. Напишите тесты, демонстрирующие работу фикстур

5. Создайте папку `images` со скриншотами результатов

6. Оформите README.md согласно требованиям

## **Практический пример**

**Проект приложения:**
```csharp
namespace FixtureDemo
{
    public class DatabaseService : IDisposable
    {
        private bool _disposed = false;
        public List<string> ExecutedQueries { get; } = new();
        public int ConnectionCount { get; private set; }
        
        public DatabaseService()
        {
            // Имитация установки соединения с БД
            ConnectionCount++;
            Console.WriteLine("Database connection opened");
        }
        
        public async Task<User> GetUserAsync(int id)
        {
            ExecutedQueries.Add($"SELECT * FROM Users WHERE Id = {id}");
            await Task.Delay(50); // Имитация запроса
            return new User(id, $"User{id}", $"user{id}@example.com");
        }
        
        public async Task SaveUserAsync(User user)
        {
            ExecutedQueries.Add($"INSERT INTO Users (Id, Name, Email) VALUES ({user.Id}, '{user.Name}', '{user.Email}')");
            await Task.Delay(50);
        }
        
        public void Dispose()
        {
            if (!_disposed)
            {
                ConnectionCount--;
                Console.WriteLine("Database connection closed");
                _disposed = true;
            }
        }
    }
    
    public class FileProcessor : IAsyncDisposable
    {
        private string _tempFilePath;
        public int ProcessedFiles { get; private set; }
        
        public FileProcessor()
        {
            _tempFilePath = Path.GetTempFileName();
            Console.WriteLine($"Temp file created: {_tempFilePath}");
        }
        
        public async Task WriteToFileAsync(string content)
        {
            await File.WriteAllTextAsync(_tempFilePath, content);
            ProcessedFiles++;
        }
        
        public async Task<string> ReadFromFileAsync()
        {
            return await File.ReadAllTextAsync(_tempFilePath);
        }
        
        public async ValueTask DisposeAsync()
        {
            if (_tempFilePath != null && File.Exists(_tempFilePath))
            {
                File.Delete(_tempFilePath);
                Console.WriteLine($"Temp file deleted: {_tempFilePath}");
                _tempFilePath = null;
            }
            await Task.CompletedTask;
        }
    }
    
    public class CacheService : IAsyncLifetime
    {
        private readonly Dictionary<string, object> _cache = new();
        public int CacheHits { get; private set; }
        public int CacheMisses { get; private set; }
        
        public async Task InitializeAsync()
        {
            // Имитация инициализации кэша
            await Task.Delay(100);
            Console.WriteLine("Cache service initialized");
        }
        
        public void Set(string key, object value)
        {
            _cache[key] = value;
        }
        
        public T Get<T>(string key)
        {
            if (_cache.ContainsKey(key))
            {
                CacheHits++;
                return (T)_cache[key];
            }
            CacheMisses++;
            return default(T);
        }
        
        public async Task DisposeAsync()
        {
            _cache.Clear();
            await Task.Delay(50);
            Console.WriteLine("Cache service disposed");
        }
    }
    
    public class User
    {
        public int Id { get; set; }
        public string Name { get; set; }
        public string Email { get; set; }
        
        public User(int id, string name, string email)
        {
            Id = id;
            Name = name;
            Email = email;
        }
    }
    
    public class Configuration
    {
        public string Environment { get; set; } = "Test";
        public string DatabaseConnection { get; set; } = "Server=test;Database=testdb";
        public int MaxConnections { get; set; } = 10;
    }
}
```

**Тестовый проект с фикстурами:**

```csharp
using Xunit;
using FixtureDemo;

namespace FixtureDemo.Tests
{
    // 1. Class Fixture с IDisposable
    public class DatabaseFixture : IDisposable
    {
        public DatabaseService Database { get; }
        public int InitializationTime { get; }
        
        public DatabaseFixture()
        {
            Database = new DatabaseService();
            InitializationTime = Environment.TickCount;
            Console.WriteLine($"DatabaseFixture created at {InitializationTime}");
        }
        
        public void Dispose()
        {
            Database?.Dispose();
            Console.WriteLine($"DatabaseFixture disposed after {Environment.TickCount - InitializationTime}ms");
        }
    }

    // 2. Class Fixture с IAsyncLifetime
    public class CacheFixture : IAsyncLifetime
    {
        public CacheService Cache { get; private set; }
        public bool IsInitialized { get; private set; }
        
        public async Task InitializeAsync()
        {
            Cache = new CacheService();
            await Cache.InitializeAsync();
            IsInitialized = true;
            Console.WriteLine("CacheFixture initialized asynchronously");
        }
        
        public async Task DisposeAsync()
        {
            if (Cache != null)
            {
                await Cache.DisposeAsync();
            }
            Console.WriteLine("CacheFixture disposed asynchronously");
        }
    }

    // 3. Collection Fixture
    public class ConfigurationFixture
    {
        public Configuration Config { get; }
        public DateTime CreatedAt { get; }
        
        public ConfigurationFixture()
        {
            Config = new Configuration();
            CreatedAt = DateTime.Now;
            Console.WriteLine($"ConfigurationFixture created at {CreatedAt}");
        }
    }

    // 4. Collection Fixture с асинхронной инициализацией
    public class FileSystemFixture : IAsyncLifetime
    {
        public string TestDirectory { get; private set; }
        public int FilesCreated { get; private set; }
        
        public async Task InitializeAsync()
        {
            TestDirectory = Path.Combine(Path.GetTempPath(), $"Test_{Guid.NewGuid()}");
            Directory.CreateDirectory(TestDirectory);
            FilesCreated = 0;
            
            // Имитация асинхронной настройки
            await Task.Delay(100);
            Console.WriteLine($"FileSystemFixture initialized with directory: {TestDirectory}");
        }
        
        public string CreateTestFile(string content = "")
        {
            var filePath = Path.Combine(TestDirectory, $"test_{FilesCreated++}.txt");
            File.WriteAllText(filePath, content);
            return filePath;
        }
        
        public async Task DisposeAsync()
        {
            if (Directory.Exists(TestDirectory))
            {
                Directory.Delete(TestDirectory, true);
                await Task.Delay(50);
            }
            Console.WriteLine("FileSystemFixture disposed");
        }
    }

    // Тестовый класс с Class Fixture (IDisposable)
    public class DatabaseServiceTests : IClassFixture<DatabaseFixture>
    {
        private readonly DatabaseFixture _fixture;
        
        public DatabaseServiceTests(DatabaseFixture fixture)
        {
            _fixture = fixture;
            Console.WriteLine($"DatabaseServiceTests constructor - Fixture initialized {Environment.TickCount - _fixture.InitializationTime}ms ago");
        }
        
        [Fact]
        public async Task GetUserAsync_ValidId_ReturnsUser()
        {
            // Arrange
            var userId = 1;
            
            // Act
            var user = await _fixture.Database.GetUserAsync(userId);
            
            // Assert
            Assert.NotNull(user);
            Assert.Equal(userId, user.Id);
            Assert.Contains($"SELECT * FROM Users WHERE Id = {userId}", _fixture.Database.ExecutedQueries);
        }
        
        [Fact]
        public async Task SaveUserAsync_ValidUser_SavesSuccessfully()
        {
            // Arrange
            var user = new User(2, "Test User", "test@example.com");
            
            // Act
            await _fixture.Database.SaveUserAsync(user);
            
            // Assert
            Assert.Contains($"INSERT INTO Users", _fixture.Database.ExecutedQueries[0]);
        }
        
        [Fact]
        public void DatabaseConnection_SharedBetweenTests_SameInstance()
        {
            // Assert
            Assert.NotNull(_fixture.Database);
            Assert.Equal(1, _fixture.Database.ConnectionCount);
        }
    }

    // Тестовый класс с Class Fixture (IAsyncLifetime)
    public class CacheServiceTests : IClassFixture<CacheFixture>
    {
        private readonly CacheFixture _fixture;
        
        public CacheServiceTests(CacheFixture fixture)
        {
            _fixture = fixture;
            Console.WriteLine("CacheServiceTests constructor");
        }
        
        [Fact]
        public void CacheFixture_IsInitialized_ReturnsTrue()
        {
            // Assert
            Assert.True(_fixture.IsInitialized);
            Assert.NotNull(_fixture.Cache);
        }
        
        [Fact]
        public void SetAndGet_ValidData_WorksCorrectly()
        {
            // Arrange
            var key = "test_key";
            var value = "test_value";
            
            // Act
            _fixture.Cache.Set(key, value);
            var result = _fixture.Cache.Get<string>(key);
            
            // Assert
            Assert.Equal(value, result);
            Assert.Equal(1, _fixture.Cache.CacheHits);
        }
        
        [Fact]
        public void Get_NonExistentKey_ReturnsDefault()
        {
            // Act
            var result = _fixture.Cache.Get<string>("non_existent");
            
            // Assert
            Assert.Null(result);
            Assert.Equal(1, _fixture.Cache.CacheMisses);
        }
    }

    // Определение коллекции для Collection Fixture
    [CollectionDefinition("ConfigurationCollection")]
    public class ConfigurationCollection : ICollectionFixture<ConfigurationFixture>
    {
        // Этот класс не содержит кода, только определение коллекции
    }

    // Тестовые классы в одной коллекции разделяют фикстуру
    [Collection("ConfigurationCollection")]
    public class ConfigurationTests1
    {
        private readonly ConfigurationFixture _fixture;
        
        public ConfigurationTests1(ConfigurationFixture fixture)
        {
            _fixture = fixture;
            Console.WriteLine($"ConfigurationTests1 - Fixture created at {_fixture.CreatedAt}");
        }
        
        [Fact]
        public void Configuration_HasTestEnvironment()
        {
            // Assert
            Assert.Equal("Test", _fixture.Config.Environment);
        }
        
        [Fact]
        public void Configuration_HasValidConnectionString()
        {
            // Assert
            Assert.Contains("testdb", _fixture.Config.DatabaseConnection);
        }
    }

    [Collection("ConfigurationCollection")]
    public class ConfigurationTests2
    {
        private readonly ConfigurationFixture _fixture;
        
        public ConfigurationTests2(ConfigurationFixture fixture)
        {
            _fixture = fixture;
            Console.WriteLine($"ConfigurationTests2 - Fixture created at {_fixture.CreatedAt}");
        }
        
        [Fact]
        public void Configuration_HasMaxConnections()
        {
            // Assert
            Assert.True(_fixture.Config.MaxConnections > 0);
        }
    }

    // Определение коллекции для асинхронной фикстуры
    [CollectionDefinition("FileSystemCollection")]
    public class FileSystemCollection : ICollectionFixture<FileSystemFixture>
    {
    }

    [Collection("FileSystemCollection")]
    public class FileSystemTests1
    {
        private readonly FileSystemFixture _fixture;
        
        public FileSystemTests1(FileSystemFixture fixture)
        {
            _fixture = fixture;
        }
        
        [Fact]
        public void CreateTestFile_ValidContent_FileCreated()
        {
            // Act
            var filePath = _fixture.CreateTestFile("test content");
            
            // Assert
            Assert.True(File.Exists(filePath));
            Assert.Equal("test content", File.ReadAllText(filePath));
        }
    }

    [Collection("FileSystemCollection")]
    public class FileSystemTests2
    {
        private readonly FileSystemFixture _fixture;
        
        public FileSystemTests2(FileSystemFixture fixture)
        {
            _fixture = fixture;
        }
        
        [Fact]
        public void FilesCreated_SharedCounter_ReflectsAllCreations()
        {
            // Arrange
            var initialCount = _fixture.FilesCreated;
            
            // Act
            _fixture.CreateTestFile();
            _fixture.CreateTestFile();
            
            // Assert
            Assert.Equal(initialCount + 2, _fixture.FilesCreated);
        }
    }

    // Комплексный пример с несколькими фикстурами
    public class ComplexFixture : IAsyncLifetime
    {
        public DatabaseService Database { get; private set; }
        public CacheService Cache { get; private set; }
        public string TestData { get; private set; }
        
        public async Task InitializeAsync()
        {
            Database = new DatabaseService();
            Cache = new CacheService();
            await Cache.InitializeAsync();
            
            TestData = "Initialized at " + DateTime.Now.ToString("HH:mm:ss.fff");
            Console.WriteLine($"ComplexFixture initialized: {TestData}");
            
            await Task.Delay(100); // Имитация сложной инициализации
        }
        
        public async Task DisposeAsync()
        {
            Database?.Dispose();
            if (Cache != null)
            {
                await Cache.DisposeAsync();
            }
            Console.WriteLine("ComplexFixture disposed");
        }
    }

    public class IntegrationTests : IClassFixture<ComplexFixture>
    {
        private readonly ComplexFixture _fixture;
        
        public IntegrationTests(ComplexFixture fixture)
        {
            _fixture = fixture;
        }
        
        [Fact]
        public async Task DatabaseAndCache_Integration_WorksTogether()
        {
            // Arrange
            var user = new User(1, "Integration User", "integration@test.com");
            
            // Act - сохраняем в БД и кэшируем
            await _fixture.Database.SaveUserAsync(user);
            _fixture.Cache.Set("user_1", user);
            
            // Assert
            var cachedUser = _fixture.Cache.Get<User>("user_1");
            Assert.NotNull(cachedUser);
            Assert.Equal(user.Name, cachedUser.Name);
        }
        
        [Fact]
        public void ComplexFixture_SharedState_Consistent()
        {
            // Assert
            Assert.NotNull(_fixture.TestData);
            Assert.Contains("Initialized at", _fixture.TestData);
        }
    }

    // Тесты для демонстрации времени жизни фикстур
    public class FixtureLifetimeTests : IClassFixture<DatabaseFixture>
    {
        private readonly DatabaseFixture _fixture;
        private static int _testCounter = 0;
        private readonly int _instanceNumber;
        
        public FixtureLifetimeTests(DatabaseFixture fixture)
        {
            _fixture = fixture;
            _instanceNumber = ++_testCounter;
            Console.WriteLine($"FixtureLifetimeTests instance {_instanceNumber} created");
        }
        
        [Fact]
        public void Test1_FixtureIsShared()
        {
            Console.WriteLine($"Test1 running in instance {_instanceNumber}");
            Assert.NotNull(_fixture.Database);
        }
        
        [Fact] 
        public void Test2_FixtureIsSameInstance()
        {
            Console.WriteLine($"Test2 running in instance {_instanceNumber}");
            Assert.NotNull(_fixture.Database);
        }
        
        [Fact]
        public void Test3_VerifyFixtureReuse()
        {
            Console.WriteLine($"Test3 running in instance {_instanceNumber}");
            Assert.True(_fixture.InitializationTime > 0);
        }
    }
}
```

---

## **Варианты заданий**

**Вариант 1:** Система кэширования с фикстурами
- CacheFixture (IAsyncLifetime)
- MemoryCacheFixture (IDisposable)
- DistributedCacheFixture

**Вариант 2:** База данных с фикстурами
- DatabaseFixture (IDisposable)
- TransactionFixture (IAsyncLifetime)
- MigrationFixture

**Вариант 3:** Файловая система с фикстурами
- TempFileFixture (IAsyncDisposable)
- DirectoryFixture (IDisposable)
- FileStreamFixture

**Вариант 4:** Сетевые сервисы с фикстурами
- HttpClientFixture (IDisposable)
- WebServerFixture (IAsyncLifetime)
- ApiClientFixture

**Вариант 5:** Конфигурация с фикстурами
- AppConfigFixture (IDisposable)
- EnvironmentFixture (IAsyncLifetime)
- SettingsFixture

**Вариант 6:** Брокер сообщений с фикстурами
- MessageQueueFixture (IAsyncLifetime)
- TopicFixture (IDisposable)
- SubscriptionFixture

**Вариант 7:** Хранилище объектов с фикстурами
- BlobStorageFixture (IAsyncDisposable)
- ContainerFixture (IDisposable)
- ObjectFixture

**Вариант 8:** Аутентификация с фикстурами
- AuthServerFixture (IAsyncLifetime)
- TokenFixture (IDisposable)
- UserSessionFixture

**Вариант 9:** Логирование с фикстурами
- LoggerFixture (IDisposable)
- LogFileFixture (IAsyncDisposable)
- AuditFixture

**Вариант 10:** Шифрование с фикстурами
- CryptoFixture (IDisposable)
- KeyVaultFixture (IAsyncLifetime)
- CertificateFixture

**Вариант 11:** Валидация с фикстурами
- ValidatorFixture (IDisposable)
- SchemaFixture (IAsyncLifetime)
- RuleFixture

**Вариант 12:** Отчеты с фикстурами
- ReportFixture (IAsyncLifetime)
- TemplateFixture (IDisposable)
- ExportFixture

**Вариант 13:** Планировщик с фикстурами
- SchedulerFixture (IAsyncLifetime)
- JobFixture (IDisposable)
- TimerFixture

**Вариант 14:** Геоданные с фикстурами
- GeoServiceFixture (IDisposable)
- MapFixture (IAsyncLifetime)
- LocationFixture

**Вариант 15:** Медиа обработка с фикстурами
- ImageProcessorFixture (IDisposable)
- VideoFixture (IAsyncLifetime)
- AudioFixture

---

## **Критерии оценки**

**5 (Отлично):**
- Реализованы все типы фикстур (IDisposable, IAsyncLifetime, IAsyncDisposable)
- Созданы Class Fixture и Collection Fixture
- Фикстуры корректно управляют ресурсами
- Написаны тесты, демонстрирующие разделение состояния
- Есть примеры комплексных фикстур
- Все тесты проходят, ресурсы освобождаются

**4 (Хорошо):**
- Реализованы основные типы фикстур
- Созданы Class Fixture и Collection Fixture
- Фикстуры работают корректно
- Написаны базовые тесты
- Все тесты проходят

**3 (Удовлетворительно):**
- Реализованы только Class Fixture
- Есть ошибки в управлении ресурсами
- Тесты покрывают базовые сценарии
- Возможны утечки ресурсов

**2 (Неудовлетворительно):**
- Фикстуры не реализованы
- Тесты не используют фикстуры
- Ресурсы не освобождаются
- Тесты не проходят

---

## **Контрольные вопросы**

1. В чем разница между Class Fixture и Collection Fixture?
2. Когда следует использовать IAsyncLifetime вместо IDisposable?
3. Как фикстуры помогают оптимизировать выполнение тестов?
4. Какие проблемы решают Collection Fixture?
5. Как обеспечить изоляцию тестов при использовании фикстур?
6. Когда фикстуры могут быть антипаттерном?
7. Как отлаживать проблемы с временем жизни фикстур?

---

## **Пример README.md для варианта 1**

```markdown
# Практическая работа: Работа с фикстурами данных

**Вариант: 1**

**Задание:**
Реализовать систему кэширования с использованием фикстур:
- CacheFixture (IAsyncLifetime) - для асинхронной инициализации кэша
- MemoryCacheFixture (IDisposable) - для управления памятью
- DistributedCacheFixture - коллекционная фикстура для распределенного кэша

**Код фикстур:**

```csharp
// FixtureDemo.Tests/CacheFixture.cs
public class CacheFixture : IAsyncLifetime
{
    public CacheService Cache { get; private set; }
    
    public async Task InitializeAsync()
    {
        Cache = new CacheService();
        await Cache.InitializeAsync();
        // Предзагрузка данных
        Cache.Set("preloaded", "data");
    }
    
    public async Task DisposeAsync()
    {
        await Cache.DisposeAsync();
    }
}

// FixtureDemo.Tests/MemoryCacheFixture.cs  
public class MemoryCacheFixture : IDisposable
{
    public MemoryCache Cache { get; }
    private readonly MemoryStream _sharedStream;
    
    public MemoryCacheFixture()
    {
        Cache = new MemoryCache();
        _sharedStream = new MemoryStream();
    }
    
    public void Dispose()
    {
        _sharedStream?.Dispose();
        Cache?.Dispose();
    }
}

// FixtureDemo.Tests/DistributedCacheFixture.cs
public class DistributedCacheFixture : IAsyncLifetime
{
    public DistributedCache Cache { get; private set; }
    public string ConnectionString { get; }
    
    public DistributedCacheFixture()
    {
        ConnectionString = "Server=test;Database=cache;";
    }
    
    public async Task InitializeAsync()
    {
        Cache = new DistributedCache(ConnectionString);
        await Cache.ConnectAsync();
    }
    
    public async Task DisposeAsync()
    {
        await Cache.DisconnectAsync();
    }
}

[CollectionDefinition("DistributedCacheCollection")]
public class DistributedCacheCollection : ICollectionFixture<DistributedCacheFixture>
{
}
```

**Пример использования:**

```csharp
// Class Fixture
public class CacheTests : IClassFixture<CacheFixture>
{
    private readonly CacheFixture _fixture;
    
    public CacheTests(CacheFixture fixture)
    {
        _fixture = fixture;
    }
    
    [Fact]
    public void Cache_IsInitialized_Works()
    {
        var data = _fixture.Cache.Get<string>("preloaded");
        Assert.Equal("data", data);
    }
}

// Collection Fixture  
[Collection("DistributedCacheCollection")]
public class DistributedCacheTests1
{
    private readonly DistributedCacheFixture _fixture;
    
    public DistributedCacheTests1(DistributedCacheFixture fixture)
    {
        _fixture = fixture;
    }
    
    [Fact]
    public async Task DistributedCache_SharedConnection_Works()
    {
        await _fixture.Cache.SetAsync("key", "value");
        var result = await _fixture.Cache.GetAsync<string>("key");
        Assert.Equal("value", result);
    }
}
```

**Результат выполнения тестов:**
![Скриншот тестов](images/test_results.png)

**Логи инициализации фикстур:**
```
CacheFixture initialized asynchronously
DatabaseFixture created at 123456789
ConfigurationFixture created at 2024-01-15 10:30:00
FileSystemFixture initialized with directory: C:\Temp\Test_abc123
```
```