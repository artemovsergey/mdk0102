# Практическая работа 4. Написание первых юнит-тестов с xUnit

### **Тема**
Основы модульного тестирования. Создание юнит-тестов для простых функций с использованием фреймворка xUnit в экосистеме .NET.

### **Цель**
Сформировать у студентов практические навыки написания юнит-тестов:
*   Создание тестового проекта.
*   Подключение необходимых зависимостей.
*   Написание тестовых методов с использованием атрибутов xUnit.
*   Применение основных утверждений (Assert) для проверки ожидаемого результата.
*   Понимание принципов изоляции и организации тестового кода (Arrange-Act-Assert).

### **Теоретическая часть**

**Юнит-тест (модульный тест)** — это способ проверки корректности работы отдельного, изолированного модуля исходного кода (чаще всего — одного метода или функции). В контексте .NET под "модулем" обычно подразумевается метод класса.

**xUnit** — это популярный, свободно распространяемый фреймворк для написания модульных тестов для .NET. Он отличается простотой и расширяемостью.

**Основные понятия xUnit:**
*   **Тестовый метод:** Метод, помеченный атрибутом `[Fact]` или `[Theory]`. Содержит код, проверяющий определенную функциональность.
*   **`[Fact]`:** Атрибут для пометки метода как тестового, который должен всегда выполняться одинаково, без входящих данных.
*   **`[Theory]`:** Атрибут для пометки параметризованного тестового метода, который выполняется многократно с разными наборами данных, предоставляемыми атрибутами `[InlineData]`, `[MemberData]` и т.д.
*   **Assert (Утверждение):** Класс, содержащий статические методы для проверки различных условий (равенство, истинность, исключения и пр.).
    *   `Assert.Equal(expected, actual)` — проверяет равенство ожидаемого и фактического значения.
    *   `Assert.True(condition)` — проверяет, что условие истинно.
    *   `Assert.False(condition)` — проверяет, что условие ложно.
    *   `Assert.Null(object)` / `Assert.NotNull(object)` — проверяет объект на `null`.
    *   `Assert.Throws<ExceptionType>(action)` — проверяет, что выполнение кода вызывает исключение указанного типа.

**Принцип AAA (Arrange-Act-Assert):**
Стандартный подход к структурированию тестового метода:
1.  **Arrange (Подготовка):** Инициализация объектов, настройка тестовых данных. Подготовка системы к тесту.
2.  **Act (Действие):** Выполнение действия или вызов метода, который мы тестируем.
3.  **Assert (Проверка):** Проверка, что результат выполнения действия соответствует ожиданиям.

### **Ход работы**

1.  Создайте новое решение в Visual Studio с двумя проектами:
    *   **Проект приложения (Class Library):** `StringCalculatorLib`
    *   **Тестовый проект (xUnit Test Project):** `StringCalculatorLib.Tests`
2.  Добавьте в проекте приложения ссылку на тестовый проект.
3.  В проекте `StringCalculatorLib` создайте класс `Calculator` и реализуйте в нем методы согласно вашему варианту задания.
4.  В проекте `StringCalculatorLib.Tests` создайте класс `CalculatorTests`.
5.  В классе `CalculatorTests` напишите юнит-тесты для всех методов класса `Calculator` из вашего варианта. Каждый тест должен проверять одну определенную функциональность.
6.  Убедитесь, что все тесты проходят (`Test Explorer` -> `Run All Tests`).
7.  Создайте папку `images` в корне репозитория и добавьте в нее скриншот обозревателя тестов (`Test Explorer`) с результатами успешного прохождения всех ваших тестов.
8.  Создайте файл `README.md` и заполните его согласно требованиям.

### **Практический пример**

**Задание:** Протестировать метод `int Add(int a, int b)`, который возвращает сумму двух чисел.

**1. Проект приложения (`StringCalculatorLib/Calculator.cs`):**

```csharp
namespace StringCalculatorLib
{
    public class Calculator
    {
        public int Add(int a, int b)
        {
            return a + b;
        }
    }
}
```

**2. Тестовый проект (`StringCalculatorLib.Tests/CalculatorTests.cs`):**

```csharp
using Xunit;
using StringCalculatorLib;

namespace StringCalculatorLib.Tests
{
    public class CalculatorTests
    {
        [Fact] // Тест без параметров
        public void Add_PositiveNumbers_ReturnsCorrectSum()
        {
            // Arrange
            var calculator = new Calculator();
            int a = 5;
            int b = 3;
            int expected = 8;

            // Act
            int actual = calculator.Add(a, b);

            // Assert
            Assert.Equal(expected, actual);
        }

        [Theory] // Параметризованный тест
        [InlineData(0, 0, 0)]
        [InlineData(-1, -1, -2)]
        [InlineData(100, 200, 300)]
        public void Add_VariousNumbers_ReturnsCorrectSum(int a, int b, int expected)
        {
            // Arrange
            var calculator = new Calculator();

            // Act
            int actual = calculator.Add(a, b);

            // Assert
            Assert.Equal(expected, actual);
        }
    }
}
```

---

### **Варианты заданий**

Студент выбирает вариант, соответствующий его номеру в журнале.

**Вариант 1:** Метод `bool IsEven(int number)` возвращает `true`, если число четное.
**Вариант 2:** Метод `bool IsPrime(int number)` возвращает `true`, если число простое.
**Вариант 3:** Метод `string ReverseString(string input)` возвращает перевернутую строку.
**Вариант 4:** Метод `int FindMax(int[] array)` возвращает максимальный элемент массива. Массив не пустой.
**Вариант 5:** Метод `int Factorial(int n)` вычисляет факториал неотрицательного числа n.
**Вариант 6:** Метод `string RemoveSpaces(string input)` удаляет все пробелы из строки.
**Вариант 7:** Метод `bool IsPalindrome(string input)` проверяет, является ли строка палиндромом (игнорируя регистр).
**Вариант 8:** Метод `int[] GetFibonacciSequence(int n)` возвращает массив первых n чисел Фибоначчи.
**Вариант 9:** Метод `int CountVowels(string input)` возвращает количество гласных букв в строке (только латиница).
**Вариант 10:** Метод `bool IsValidEmail(string email)` проверяет строку на базовое соответствие формату email (содержит '@' и '.').
**Вариант 11:** Метод `int GCD(int a, int b)` возвращает наибольший общий делитель двух чисел.
**Вариант 12:** Метод `double Power(double base, int exponent)` возводит число в целую положительную степень.
**Вариант 13:** Метод `string ConvertToBinary(int number)` преобразует целое число в его двоичное строковое представление.
**Вариант 14:** Метод `bool IsLeapYear(int year)` проверяет, является ли год високосным.
**Вариант 15:** Метод `int[] BubbleSort(int[] array)` сортирует массив целых чисел по возрастанию методом пузырька.

---

### **Критерии оценки**

*   **5 (Отлично):**
    *   Созданы оба проекта (приложения и тестов), настроена ссылка.
    *   Реализована корректная логика метода согласно варианту.
    *   Написано не менее 3 различных юнит-тестов, покрывающих основные, граничные и ошибочные случаи (если применимо).
    *   Тесты используют как `[Fact]`, так и `[Theory]` с `[InlineData]` где это уместно.
    *   Код чистый, хорошо отформатирован, имена тестовых методов описательные.
    *   Все тесты проходят.
    *   Репозиторий содержит папку `images` со скриншотом и корректный `README.md`.

*   **4 (Хорошо):**
    *   Выполнены все основные пункты.
    *   Логика метода и тестов в целом корректна.
    *   Недостаточное покрытие тестами (например, только основные случаи) или не использованы параметризованные тесты там, где они явно напрашиваются.
    *   Возможны небольшие недочеты в именовании или организации кода.

*   **3 (Удовлетворительно):**
    *   Созданы проекты, но есть ошибки в настройке зависимостей.
    *   Логика метода содержит незначительные ошибки, но тесты в основном проходят.
    *   Написано только 1-2 простых теста, покрывающих лишь очевидные сценарии.
    *   Структура AAA в тестах не всегда соблюдается.

*   **2 (Неудовлетворительно):**
    *   Не созданы или некорректно созданы проекты.
    *   Логика метода работает неверно.
    *   Тесты не написаны, не компилируются или не проходят.
    *   Работа не сдана.

---

### **Контрольные вопросы**

1.  Что такое юнит-тест и какова его основная цель?
2.  В чем разница между атрибутами `[Fact]` и `[Theory]` в xUnit?
3.  Опишите три фазы паттерна "Arrange-Act-Assert".
4.  Какие методы класса `Assert` вы знаете и для чего они используются?
5.  Почему важно, чтобы юнит-тесты были быстрыми и изолированными?
6.  Что такое "покрытие кода" (code coverage) и почему оно важно?
7.  Как бы вы протестировали метод, который в случае ошибки должен выбрасывать исключение?

---

### **Требования к репозиторию и README.md**

Структура репозитория:
```
YourRepoName/
├── StringCalculatorLib/
│   ├── Calculator.cs
│   └── StringCalculatorLib.csproj
├── StringCalculatorLib.Tests/
│   ├── CalculatorTests.cs
│   └── StringCalculatorLib.Tests.csproj
├── images/
│   └── test_results.png (скриншот Test Explorer)
└── README.md
```

**Содержание файла `README.md` (пример для варианта 1):**

```markdown
# Практическая работа №X: Написание первых юнит-тестов с xUnit

**Вариант: 1**

**Задание:**
Реализовать в классе `Calculator` метод `bool IsEven(int number)`, который возвращает `true`, если число четное. Написать юнит-тесты для этого метода, покрывающие основные и граничные случаи.

**Код реализации:**

```csharp
// StringCalculatorLib/Calculator.cs
using System;

namespace StringCalculatorLib
{
    public class Calculator
    {
        public bool IsEven(int number)
        {
            return number % 2 == 0;
        }
    }
}
```

**Код тестов:**

```csharp
// StringCalculatorLib.Tests/CalculatorTests.cs
using Xunit;
using StringCalculatorLib;

namespace StringCalculatorLib.Tests
{
    public class CalculatorTests
    {
        [Theory]
        [InlineData(2)]
        [InlineData(0)]
        [InlineData(-4)]
        public void IsEven_EvenNumbers_ReturnsTrue(int number)
        {
            // Arrange
            var calc = new Calculator();

            // Act
            bool result = calc.IsEven(number);

            // Assert
            Assert.True(result);
        }

        [Theory]
        [InlineData(1)]
        [InlineData(3)]
        [InlineData(-1)]
        public void IsEven_OddNumbers_ReturnsFalse(int number)
        {
            // Arrange
            var calc = new Calculator();

            // Act
            bool result = calc.IsEven(number);

            // Assert
            Assert.False(result);
        }
    }
}
```

**Результат выполнения тестов:**
![Скриншот тестов](images/test_results.png)
```