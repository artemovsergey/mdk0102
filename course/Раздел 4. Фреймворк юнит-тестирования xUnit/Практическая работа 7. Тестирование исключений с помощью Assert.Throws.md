# Практическая работа 7. Тестирование исключений с помощью Assert.Throws в xUnit

## **Тема**
Освоение техники тестирования исключительных ситуаций с использованием методов Assert.Throws в xUnit.

## **Цель**
Научить студентов правильно тестировать исключения в юнит-тестах:
- Использование Assert.Throws для синхронных методов
- Использование Assert.ThrowsAsync для асинхронных методов
- Проверка типа исключения и его свойств
- Тестирование пользовательских исключений

## **Теоретическая часть**

**Тестирование исключений** - важная часть модульного тестирования, которая проверяет, что код правильно обрабатывает ошибочные ситуации и генерирует соответствующие исключения.

### **Основные методы для тестирования исключений:**

**1. `Assert.Throws<T>()`**
Проверяет, что выполнение кода вызывает исключение указанного типа T.

```csharp
[Fact]
public void Method_InvalidInput_ThrowsArgumentException()
{
    // Arrange
    var calculator = new Calculator();
    
    // Act & Assert
    var exception = Assert.Throws<ArgumentException>(() => 
        calculator.Divide(10, 0));
    
    // Дополнительная проверка свойств исключения
    Assert.Contains("divide by zero", exception.Message);
}
```

**2. `Assert.ThrowsAsync<T>()`**
Асинхронная версия для тестирования методов, возвращающих Task.

```csharp
[Fact]
public async Task MethodAsync_InvalidInput_ThrowsException()
{
    // Arrange
    var service = new DataService();
    
    // Act & Assert
    var exception = await Assert.ThrowsAsync<InvalidOperationException>(() => 
        service.GetDataAsync(-1));
    
    Assert.Equal("Invalid ID", exception.Message);
}
```

**3. Проверка свойств исключения**
После перехвата исключения можно проверить его дополнительные свойства:

```csharp
var exception = Assert.Throws<ArgumentOutOfRangeException>(() => 
    methodCall);
    
Assert.Equal("parameterName", exception.ParamName);
Assert.Equal(expectedValue, exception.ActualValue);
```

### **Паттерны тестирования исключений:**

**1. Arrange-Act-Assert с лямбда-выражением**
```csharp
[Fact]
public void Test_ExceptionPattern()
{
    // Arrange
    var obj = new TestClass();
    
    // Act & Assert в одном вызове
    Assert.Throws<InvalidOperationException>(() => obj.Method());
}
```

**2. Проверка нескольких свойств исключения**
```csharp
[Fact]
public void Test_ExceptionProperties()
{
    // Arrange
    var validator = new InputValidator();
    
    // Act
    var exception = Assert.Throws<ValidationException>(() => 
        validator.Validate(null));
    
    // Assert - проверка нескольких свойств
    Assert.Equal("Input cannot be null", exception.Message);
    Assert.Equal(ErrorCode.NullInput, exception.ErrorCode);
    Assert.NotNull(exception.Timestamp);
}
```

## **Ход работы**

1. Создайте решение с двумя проектами:
   - **Проект приложения**: `ExceptionTestingDemo`
   - **Тестовый проект**: `ExceptionTestingDemo.Tests`

2. Реализуйте классы согласно вашему варианту задания

3. Создайте пользовательские исключения где это необходимо

4. Напишите тесты, покрывающие все исключительные ситуации

5. Используйте Assert.Throws и Assert.ThrowsAsync

6. Проверяйте свойства исключений (Message, ParamName, ErrorCode и т.д.)

7. Создайте папку `images` со скриншотом результатов

8. Оформите README.md согласно требованиям

## **Практический пример**

**Проект приложения:**
```csharp
namespace ExceptionTestingDemo
{
    // Пользовательское исключение
    public class InsufficientFundsException : Exception
    {
        public decimal CurrentBalance { get; }
        public decimal RequestedAmount { get; }
        
        public InsufficientFundsException(decimal currentBalance, decimal requestedAmount)
            : base($"Insufficient funds. Current balance: {currentBalance}, requested: {requestedAmount}")
        {
            CurrentBalance = currentBalance;
            RequestedAmount = requestedAmount;
        }
    }
    
    public class BankAccount
    {
        public string AccountNumber { get; }
        public decimal Balance { get; private set; }
        
        public BankAccount(string accountNumber, decimal initialBalance)
        {
            if (string.IsNullOrWhiteSpace(accountNumber))
                throw new ArgumentException("Account number cannot be empty", nameof(accountNumber));
                
            if (initialBalance < 0)
                throw new ArgumentOutOfRangeException(nameof(initialBalance), "Initial balance cannot be negative");
                
            AccountNumber = accountNumber;
            Balance = initialBalance;
        }
        
        public void Deposit(decimal amount)
        {
            if (amount <= 0)
                throw new ArgumentOutOfRangeException(nameof(amount), "Deposit amount must be positive");
                
            Balance += amount;
        }
        
        public void Withdraw(decimal amount)
        {
            if (amount <= 0)
                throw new ArgumentOutOfRangeException(nameof(amount), "Withdrawal amount must be positive");
                
            if (amount > Balance)
                throw new InsufficientFundsException(Balance, amount);
                
            Balance -= amount;
        }
        
        public async Task TransferAsync(BankAccount targetAccount, decimal amount)
        {
            if (targetAccount == null)
                throw new ArgumentNullException(nameof(targetAccount));
                
            if (amount <= 0)
                throw new ArgumentOutOfRangeException(nameof(amount), "Transfer amount must be positive");
                
            if (amount > Balance)
                throw new InsufficientFundsException(Balance, amount);
                
            // Имитация асинхронной операции
            await Task.Delay(100);
            Balance -= amount;
            targetAccount.Balance += amount;
        }
    }
    
    public class DataValidator
    {
        public void ValidateEmail(string email)
        {
            if (string.IsNullOrWhiteSpace(email))
                throw new ArgumentException("Email cannot be null or empty", nameof(email));
                
            if (!email.Contains("@"))
                throw new FormatException("Invalid email format");
                
            if (email.Length > 100)
                throw new ArgumentException("Email is too long", nameof(email));
        }
        
        public void ValidateAge(int age)
        {
            if (age < 0)
                throw new ArgumentOutOfRangeException(nameof(age), "Age cannot be negative");
                
            if (age > 150)
                throw new ArgumentOutOfRangeException(nameof(age), "Age is not realistic");
        }
    }
}
```

**Тестовый проект:**
```csharp
using Xunit;
using ExceptionTestingDemo;

namespace ExceptionTestingDemo.Tests
{
    public class BankAccountTests
    {
        [Theory]
        [InlineData("")]
        [InlineData(" ")]
        [InlineData(null)]
        public void Constructor_InvalidAccountNumber_ThrowsArgumentException(string accountNumber)
        {
            // Act & Assert
            var exception = Assert.Throws<ArgumentException>(() => 
                new BankAccount(accountNumber, 100));
                
            Assert.Equal("accountNumber", exception.ParamName);
            Assert.Contains("cannot be empty", exception.Message);
        }

        [Fact]
        public void Constructor_NegativeInitialBalance_ThrowsArgumentOutOfRangeException()
        {
            // Act & Assert
            var exception = Assert.Throws<ArgumentOutOfRangeException>(() => 
                new BankAccount("12345", -100));
                
            Assert.Equal("initialBalance", exception.ParamName);
            Assert.Contains("cannot be negative", exception.Message);
        }

        [Theory]
        [InlineData(0)]
        [InlineData(-50)]
        public void Deposit_InvalidAmount_ThrowsArgumentOutOfRangeException(decimal amount)
        {
            // Arrange
            var account = new BankAccount("12345", 100);

            // Act & Assert
            var exception = Assert.Throws<ArgumentOutOfRangeException>(() => 
                account.Deposit(amount));
                
            Assert.Equal("amount", exception.ParamName);
            Assert.Contains("must be positive", exception.Message);
        }

        [Fact]
        public void Withdraw_AmountExceedsBalance_ThrowsInsufficientFundsException()
        {
            // Arrange
            var account = new BankAccount("12345", 100);
            decimal withdrawalAmount = 150;

            // Act & Assert
            var exception = Assert.Throws<InsufficientFundsException>(() => 
                account.Withdraw(withdrawalAmount));
                
            // Проверка пользовательских свойств исключения
            Assert.Equal(100, exception.CurrentBalance);
            Assert.Equal(150, exception.RequestedAmount);
            Assert.Contains("Insufficient funds", exception.Message);
        }

        [Fact]
        public async Task TransferAsync_NullTargetAccount_ThrowsArgumentNullException()
        {
            // Arrange
            var sourceAccount = new BankAccount("12345", 100);

            // Act & Assert
            var exception = await Assert.ThrowsAsync<ArgumentNullException>(() => 
                sourceAccount.TransferAsync(null, 50));
                
            Assert.Equal("targetAccount", exception.ParamName);
        }

        [Fact]
        public async Task TransferAsync_InsufficientFunds_ThrowsInsufficientFundsException()
        {
            // Arrange
            var sourceAccount = new BankAccount("12345", 100);
            var targetAccount = new BankAccount("67890", 50);

            // Act & Assert
            var exception = await Assert.ThrowsAsync<InsufficientFundsException>(() => 
                sourceAccount.TransferAsync(targetAccount, 200));
                
            Assert.Equal(100, exception.CurrentBalance);
            Assert.Equal(200, exception.RequestedAmount);
        }
    }

    public class DataValidatorTests
    {
        private readonly DataValidator _validator = new DataValidator();

        [Theory]
        [InlineData("")]
        [InlineData(" ")]
        [InlineData(null)]
        public void ValidateEmail_InvalidInput_ThrowsArgumentException(string email)
        {
            // Act & Assert
            var exception = Assert.Throws<ArgumentException>(() => 
                _validator.ValidateEmail(email));
                
            Assert.Equal("email", exception.ParamName);
        }

        [Theory]
        [InlineData("invalid-email")]
        [InlineData("user.domain.com")]
        [InlineData("user@")]
        public void ValidateEmail_InvalidFormat_ThrowsFormatException(string email)
        {
            // Act & Assert
            var exception = Assert.Throws<FormatException>(() => 
                _validator.ValidateEmail(email));
                
            Assert.Contains("Invalid email format", exception.Message);
        }

        [Fact]
        public void ValidateEmail_TooLongEmail_ThrowsArgumentException()
        {
            // Arrange
            string longEmail = new string('a', 50) + "@" + new string('b', 50) + ".com";

            // Act & Assert
            var exception = Assert.Throws<ArgumentException>(() => 
                _validator.ValidateEmail(longEmail));
                
            Assert.Equal("email", exception.ParamName);
            Assert.Contains("too long", exception.Message);
        }

        [Theory]
        [InlineData(-1)]
        [InlineData(-100)]
        public void ValidateAge_NegativeAge_ThrowsArgumentOutOfRangeException(int age)
        {
            // Act & Assert
            var exception = Assert.Throws<ArgumentOutOfRangeException>(() => 
                _validator.ValidateAge(age));
                
            Assert.Equal("age", exception.ParamName);
            Assert.Contains("cannot be negative", exception.Message);
        }

        [Theory]
        [InlineData(151)]
        [InlineData(200)]
        public void ValidateAge_TooLargeAge_ThrowsArgumentOutOfRangeException(int age)
        {
            // Act & Assert
            var exception = Assert.Throws<ArgumentOutOfRangeException>(() => 
                _validator.ValidateAge(age));
                
            Assert.Equal("age", exception.ParamName);
            Assert.Contains("not realistic", exception.Message);
        }
    }

    // Тестирование правильных сценариев (без исключений)
    public class PositiveScenariosTests
    {
        [Fact]
        public void Withdraw_ValidAmount_NoExceptionThrown()
        {
            // Arrange
            var account = new BankAccount("12345", 100);

            // Act & Assert - убеждаемся, что исключение не выбрасывается
            var exception = Record.Exception(() => account.Withdraw(50));
            
            Assert.Null(exception);
        }

        [Fact]
        public async Task TransferAsync_ValidTransfer_NoExceptionThrown()
        {
            // Arrange
            var sourceAccount = new BankAccount("12345", 100);
            var targetAccount = new BankAccount("67890", 50);

            // Act & Assert - убеждаемся, что исключение не выбрасывается
            var exception = await Record.ExceptionAsync(() => 
                sourceAccount.TransferAsync(targetAccount, 50));
            
            Assert.Null(exception);
        }
    }
}
```

---

## **Варианты заданий**

**Вариант 1:** Класс `Calculator` с методами:
- `decimal Divide(decimal a, decimal b)`
- `double SquareRoot(double number)`
- `int Factorial(int n)`

**Вариант 2:** Класс `FileProcessor` с методами:
- `string ReadFile(string filePath)`
- `void WriteFile(string filePath, string content)`
- `void DeleteFile(string filePath)`

**Вариант 3:** Класс `StudentRegistry` с методами:
- `void AddStudent(Student student)`
- `Student GetStudent(int id)`
- `void UpdateGrade(int studentId, string subject, int grade)`

**Вариант 4:** Класс `InventoryManager` с методами:
- `void AddProduct(Product product)`
- `void RemoveProduct(int productId)`
- `void UpdateStock(int productId, int quantity)`

**Вариант 5:** Класс `PaymentProcessor` с методами:
- `void ProcessPayment(PaymentInfo payment)`
- `void RefundPayment(string transactionId)`
- `decimal CalculateTax(decimal amount, string countryCode)`

**Вариант 6:** Класс `UserAuthenticator` с методами:
- `bool Login(string username, string password)`
- `void Register(User user)`
- `void ChangePassword(string username, string oldPassword, string newPassword)`

**Вариант 7:** Класс `GeometryCalculator` с методами:
- `double CalculateTriangleArea(double a, double b, double c)`
- `double CalculateCircleArea(double radius)`
- `double CalculateRectangleVolume(double length, double width, double height)`

**Вариант 8:** Класс `TextProcessor` с методами:
- `string CompressText(string text)`
- `string EncryptText(string text, string key)`
- `string DecryptText(string encryptedText, string key)`

**Вариант 9:** Класс `TimeScheduler` с методами:
- `void ScheduleTask(DateTime dateTime, string task)`
- `void CancelTask(int taskId)`
- `DateTime GetNextAvailableSlot(DateTime fromDate)`

**Вариант 10:** Класс `DataParser` с методами:
- `object ParseJson(string json)`
- `object ParseXml(string xml)`
- `object ParseCsv(string csv)`

**Вариант 11:** Класс `NetworkConnector` с методами:
- `async Task ConnectAsync(string url)`
- `async Task SendDataAsync(string data)`
- `async Task<string> ReceiveDataAsync()`

**Вариант 12:** Класс `ConfigurationManager` с методами:
- `T GetSetting<T>(string key)`
- `void SetSetting<T>(string key, T value)`
- `void ValidateConfiguration()`

**Вариант 13:** Класс `MathExpressionEvaluator` с методами:
- `double Evaluate(string expression)`
- `void ValidateExpression(string expression)`
- `double CalculateDerivative(string expression, double point)`

**Вариант 14:** Класс `ImageProcessor` с методами:
- `void ResizeImage(string imagePath, int width, int height)`
- `void ConvertFormat(string imagePath, string format)`
- `void ApplyFilter(string imagePath, string filter)`

**Вариант 15:** Класс `DatabaseAccessor` с методами:
- `async Task<int> ExecuteNonQueryAsync(string sql)`
- `async Task<object> ExecuteScalarAsync(string sql)`
- `void ValidateConnectionString(string connectionString)`

---

## **Критерии оценки**

**5 (Отлично):**
- Реализованы все методы с правильной обработкой исключений
- Созданы пользовательские исключения где это необходимо
- Написаны тесты для всех исключительных ситуаций
- Использованы как Assert.Throws, так и Assert.ThrowsAsync
- Проверяются свойства исключений (Message, ParamName, пользовательские свойства)
- Написаны тесты для положительных сценариев (без исключений)
- Все тесты проходят

**4 (Хорошо):**
- Реализованы основные методы
- Тесты покрывают большинство исключительных ситуаций
- Использованы основные методы Assert.Throws
- Проверяются основные свойства исключений
- Все тесты проходят

**3 (Удовлетворительно):**
- Реализована часть методов
- Тесты покрывают только основные исключения
- Не проверяются свойства исключений
- Возможны незначительные ошибки

**2 (Неудовлетворительно):**
- Методы не реализованы или не генерируют исключения
- Тесты исключений не написаны
- Тесты не компилируются или не проходят

---

## **Контрольные вопросы**

1. В чем разница между Assert.Throws и Assert.ThrowsAsync?
2. Как проверить конкретное свойство исключения (например, ParamName)?
3. Когда следует создавать пользовательские исключения?
4. Как протестировать, что исключение НЕ было выброшено?
5. Какие типы исключений чаще всего тестируются в юнит-тестах?
6. Как организовать тестирование исключений в параметризированных тестах?
7. Почему важно тестировать не только факт исключения, но и его свойства?

---

## **Пример README.md для варианта 1**

```markdown
# Практическая работа: Тестирование исключений с помощью Assert.Throws

**Вариант: 1**

**Задание:**
Реализовать класс `Calculator` с методами:
- `decimal Divide(decimal a, decimal b)` - деление двух чисел
- `double SquareRoot(double number)` - вычисление квадратного корня
- `int Factorial(int n)` - вычисление факториала

Написать тесты, проверяющие генерацию исключений в ошибочных ситуациях.

**Код реализации:**

```csharp
// ExceptionTestingDemo/Calculator.cs
using System;

namespace ExceptionTestingDemo
{
    public class Calculator
    {
        public decimal Divide(decimal a, decimal b)
        {
            if (b == 0)
                throw new DivideByZeroException("Division by zero is not allowed");
                
            return a / b;
        }

        public double SquareRoot(double number)
        {
            if (number < 0)
                throw new ArgumentOutOfRangeException(nameof(number), 
                    "Cannot calculate square root of negative number");
                
            return Math.Sqrt(number);
        }

        public int Factorial(int n)
        {
            if (n < 0)
                throw new ArgumentOutOfRangeException(nameof(n), 
                    "Factorial is not defined for negative numbers");
                    
            if (n > 20)
                throw new OverflowException("Factorial of numbers greater than 20 causes overflow");

            if (n == 0 || n == 1)
                return 1;
                
            return n * Factorial(n - 1);
        }
    }
}
```

**Код тестов:**

```csharp
// ExceptionTestingDemo.Tests/CalculatorTests.cs
using Xunit;
using ExceptionTestingDemo;

namespace ExceptionTestingDemo.Tests
{
    public class CalculatorTests
    {
        private readonly Calculator _calculator = new Calculator();

        [Fact]
        public void Divide_DivisionByZero_ThrowsDivideByZeroException()
        {
            // Act & Assert
            var exception = Assert.Throws<DivideByZeroException>(() => 
                _calculator.Divide(10, 0));
                
            Assert.Contains("Division by zero", exception.Message);
        }

        [Theory]
        [InlineData(-1)]
        [InlineData(-10.5)]
        [InlineData(double.MinValue)]
        public void SquareRoot_NegativeNumber_ThrowsArgumentOutOfRangeException(double number)
        {
            // Act & Assert
            var exception = Assert.Throws<ArgumentOutOfRangeException>(() => 
                _calculator.SquareRoot(number));
                
            Assert.Equal("number", exception.ParamName);
            Assert.Contains("negative", exception.Message);
        }

        [Theory]
        [InlineData(-1)]
        [InlineData(-5)]
        public void Factorial_NegativeNumber_ThrowsArgumentOutOfRangeException(int n)
        {
            // Act & Assert
            var exception = Assert.Throws<ArgumentOutOfRangeException>(() => 
                _calculator.Factorial(n));
                
            Assert.Equal("n", exception.ParamName);
            Assert.Contains("not defined for negative numbers", exception.Message);
        }

        [Theory]
        [InlineData(21)]
        [InlineData(100)]
        [InlineData(int.MaxValue)]
        public void Factorial_LargeNumber_ThrowsOverflowException(int n)
        {
            // Act & Assert
            var exception = Assert.Throws<OverflowException>(() => 
                _calculator.Factorial(n));
                
            Assert.Contains("overflow", exception.Message);
        }

        // Тестирование положительных сценариев
        [Theory]
        [InlineData(4, 2, 2)]
        [InlineData(10, 3, 3.333)]
        [InlineData(0, 5, 0)]
        public void Divide_ValidNumbers_ReturnsCorrectResult(decimal a, decimal b, decimal expected)
        {
            // Act
            var result = _calculator.Divide(a, b);
            var exception = Record.Exception(() => _calculator.Divide(a, b));
            
            // Assert
            Assert.Null(exception);
            Assert.Equal(expected, result, 3);
        }

        [Fact]
        public void Factorial_ValidNumbers_NoExceptionThrown()
        {
            // Act & Assert
            var exception = Record.Exception(() => _calculator.Factorial(5));
            
            Assert.Null(exception);
        }
    }
}
```

**Результат выполнения тестов:**
![Скриншот тестов](images/test_results.png)
```