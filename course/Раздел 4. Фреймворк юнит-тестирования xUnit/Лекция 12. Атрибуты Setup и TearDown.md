# Лекция 12. Атрибуты Setup и TearDown в xUnit. Управление жизненным циклом тестов

**Цель:** Понимать философию и практическое применение методов настройки и очистки в тестовом фреймворке xUnit, научиться эффективно управлять тестовыми данными и ресурсами.

---

### **План лекции**

1.  **Философия жизненного цикла теста: почему нужны Setup и TearDown?**
2.  **Конструктор и IDisposable: подход xUnit к настройке и очистке**
3.  **Фикстуры уровня класса: IClassFixture<T> для разделяемых ресурсов**
4.  **Фикстуры уровня коллекции: ICollectionFixture<T> для кросстестовых ресурсов**
5.  **Практические примеры: базы данных, файлы, API-клиенты**
6.  **Лучшие практики и распространенные ошибки**

---

### **Подробное рассмотрение каждого пункта плана**

#### **1. Философия жизненного цикла теста: почему нужны Setup и TearDown?**

**Подробное объяснение:**

Каждый автоматизированный тест должен быть **изолированным** и **воспроизводимым**. Это означает, что тесты не должны влиять друг на друга и должны давать одинаковый результат при каждом запуске.

**Проблемы без proper Setup/TearDown:**
- **Зависимость между тестами:** Состояние одного теста влияет на результат другого
- **Утечки ресурсов:** Незакрытые соединения, файловые дескрипторы
- **Накопление данных:** База данных переполняется тестовыми данными
- **Хрупкие тесты:** Тесты проходят только в определенном порядке

**Роль тестировщика:** Создать **чистое, предсказуемое окружение** для каждого теста.

```csharp
// ПРОБЛЕМА: тесты зависят друг от друга
public class BadDatabaseTests
{
    private static int _sharedCounter = 0; // Статическое состояние - АНТИПАТТЕРН!
    private DatabaseConnection _db;

    public BadDatabaseTests()
    {
        _db = new DatabaseConnection();
    }

    [Fact]
    public void Test1_AddsUser()
    {
        _sharedCounter++;
        _db.Execute($"INSERT INTO users VALUES ('user_{_sharedCounter}')");
        // Проблема: следующий тест получит другое значение _sharedCounter
    }

    [Fact] 
    public void Test2_AddsAnotherUser()
    {
        _sharedCounter++;
        _db.Execute($"INSERT INTO users VALUES ('user_{_sharedCounter}')");
        // Результат зависит от порядка выполнения тестов!
    }
}
```

---

#### **2. Конструктор и IDisposable: подход xUnit к настройке и очистке**

**Подробное объяснение:**

В отличие от NUnit/MSTest, xUnit **не использует атрибуты `[SetUp]`/`[TearDown]`**. Вместо этого применяется более явный подход:

- **Конструктор класса** → Выполняется перед КАЖДЫМ тестом
- **IDisposable.Dispose()** → Выполняется после КАЖДОГО теста

**Базовый шаблон:**
```csharp
public class DatabaseTests : IDisposable
{
    private readonly DatabaseConnection _db;
    private readonly string _testDatabaseName;

    // КОНСТРУКТОР = SETUP
    public DatabaseTests()
    {
        // Этот код выполняется ПЕРЕД КАЖДЫМ тестом
        _testDatabaseName = $"TestDB_{Guid.NewGuid()}"; // Уникальное имя для изоляции
        _db = new DatabaseConnection();
        _db.CreateDatabase(_testDatabaseName);
        _db.Connect(_testDatabaseName);
        
        Console.WriteLine($"Setup completed for {_testDatabaseName}");
    }

    // DISPOSE = TEARDOWN
    public void Dispose()
    {
        // Этот код выполняется ПОСЛЕ КАЖДОГО теста
        _db.DeleteDatabase(_testDatabaseName);
        _db.Dispose();
        
        Console.WriteLine($"Cleanup completed for {_testDatabaseName}");
    }

    [Fact]
    public void Test1_AddUser()
    {
        // Каждый тест получает СВОЮ копию базы данных
        _db.Execute("INSERT INTO Users (Name) VALUES ('Test User 1')");
        var count = _db.ExecuteScalar<int>("SELECT COUNT(*) FROM Users");
        
        Assert.Equal(1, count);
    }

    [Fact]
    public void Test2_AddAnotherUser()
    {
        // Этот тест НЕ видит данные из Test1
        _db.Execute("INSERT INTO Users (Name) VALUES ('Test User 2')");
        var count = _db.ExecuteScalar<int>("SELECT COUNT(*) FROM Users");
        
        Assert.Equal(1, count); // Всегда 1, а не 2!
    }
}
```

**Преимущества подхода xUnit:**
- **Явность:** Легко увидеть, что является setup и teardown
- **Изоляция:** Новый экземпляр класса для каждого теста
- **Безопасность ресурсов:** Гарантированный вызов Dispose()

**Практический пример для тестировщика Web UI:**
```csharp
public class WebUITests : IDisposable
{
    private readonly IWebDriver _driver;
    private readonly string _testScreenshotDir;

    public WebUITests()
    {
        // Setup: инициализация браузера для каждого теста
        _driver = new ChromeDriver();
        _driver.Manage().Window.Maximize();
        _driver.Manage().Timeouts().ImplicitWait = TimeSpan.FromSeconds(10);
        
        _testScreenshotDir = Path.Combine(TestContext.CurrentContext.TestDirectory, "screenshots");
        Directory.CreateDirectory(_testScreenshotDir);
    }

    public void Dispose()
    {
        // Teardown: закрытие браузера после каждого теста
        try
        {
            // Делаем скриншот при падении теста
            if (TestContext.CurrentContext.Result.Outcome.Status == TestStatus.Failed)
            {
                var screenshot = ((ITakesScreenshot)_driver).GetScreenshot();
                var testName = TestContext.CurrentContext.Test.Name;
                var fileName = $"{testName}_{DateTime.Now:yyyyMMdd_HHmmss}.png";
                screenshot.SaveAsFile(Path.Combine(_testScreenshotDir, fileName));
            }
        }
        finally
        {
            _driver.Quit();
            _driver.Dispose();
        }
    }

    [Fact]
    public void Login_ValidCredentials_RedirectsToDashboard()
    {
        _driver.Navigate().GoToUrl("https://example.com/login");
        _driver.FindElement(By.Id("username")).SendKeys("testuser");
        _driver.FindElement(By.Id("password")).SendKeys("password");
        _driver.FindElement(By.Id("login-btn")).Click();
        
        Assert.Equal("https://example.com/dashboard", _driver.Url);
    }
}
```

---

#### **3. Фикстуры уровня класса: IClassFixture<T> для разделяемых ресурсов**

**Подробное объяснение:**

Иногда некоторые ресурсы слишком **дорогие** для создания перед каждым тестом (например, HTTP-сервер, база данных с миграциями).

**Решение:** `IClassFixture<T>` позволяет создать ресурс **один раз** на класс и использовать его во всех тестах.

```csharp
// 1. Создаем класс фикстуры
public class DatabaseFixture : IDisposable
{
    public DatabaseConnection Db { get; private set; }
    public string DatabaseName { get; private set; }

    public DatabaseFixture()
    {
        DatabaseName = $"SharedTestDB_{Guid.NewGuid()}";
        Db = new DatabaseConnection();
        Db.CreateDatabase(DatabaseName);
        Db.Connect(DatabaseName);
        
        // Выполняем миграции базы данных (дорогая операция)
        Db.RunMigrations();
        
        Console.WriteLine($"Shared database {DatabaseName} created");
    }

    public void Dispose()
    {
        Db.DeleteDatabase(DatabaseName);
        Db.Dispose();
        Console.WriteLine($"Shared database {DatabaseName} deleted");
    }
}

// 2. Используем фикстуру в тестовом классе
public class UserRepositoryTests : IClassFixture<DatabaseFixture>
{
    private readonly DatabaseFixture _fixture;
    private readonly UserRepository _repository;

    // Фикстура инжектируется через конструктор
    public UserRepositoryTests(DatabaseFixture fixture)
    {
        _fixture = fixture;
        _repository = new UserRepository(_fixture.Db);
        
        // Очищаем таблицу перед каждым тестом для изоляции
        _fixture.Db.Execute("DELETE FROM Users");
    }

    [Fact]
    public void CreateUser_ValidData_UserIsCreated()
    {
        var user = new User { Name = "John", Email = "john@test.com" };
        
        var result = _repository.CreateUser(user);
        
        Assert.True(result > 0);
        var dbUser = _repository.GetUser(result);
        Assert.Equal("John", dbUser.Name);
    }

    [Fact]
    public void GetUser_NonExistingUser_ReturnsNull()
    {
        var user = _repository.GetUser(999);
        
        Assert.Null(user);
    }
}
```

**Когда использовать IClassFixture<T>:**
- Инициализация HTTP-сервера для тестирования API
- Поднятие тестовой базы данных с миграциями
- Создание дорогих внешних сервисов
- Настройка кэшей или конфигураций

---

#### **4. Фикстуры уровня коллекции: ICollectionFixture<T> для кросстестовых ресурсов**

**Подробное объяснение:**

Когда ресурс должен быть разделен между **несколькими тестовыми классами**, используется `ICollectionFixture<T>`.

```csharp
// 1. Создаем фикстуру (аналогично IClassFixture)
public class WebServerFixture : IDisposable
{
    public TestServer Server { get; private set; }
    public HttpClient Client { get; private set; }
    public string BaseUrl { get; private set; }

    public WebServerFixture()
    {
        Server = new TestServer(WebHost.CreateDefaultBuilder()
            .UseStartup<TestStartup>());
        Client = Server.CreateClient();
        BaseUrl = "http://localhost:5000";
        
        Console.WriteLine("Web server started");
    }

    public void Dispose()
    {
        Client?.Dispose();
        Server?.Dispose();
        Console.WriteLine("Web server stopped");
    }
}

// 2. Создаем коллекцию для группировки тестов
[CollectionDefinition("WebServerCollection")]
public class WebServerCollection : ICollectionFixture<WebServerFixture>
{
    // Класс пустой - служит только для определения коллекции
}

// 3. Помещаем тестовые классы в коллекцию
[Collection("WebServerCollection")]
public class UserApiTests
{
    private readonly WebServerFixture _fixture;

    public UserApiTests(WebServerFixture fixture)
    {
        _fixture = fixture;
    }

    [Fact]
    public async Task GetUsers_ReturnsUserList()
    {
        var response = await _fixture.Client.GetAsync("/api/users");
        response.EnsureSuccessStatusCode();
        
        var content = await response.Content.ReadAsStringAsync();
        Assert.Contains("users", content);
    }
}

[Collection("WebServerCollection")] // Тот же сервер!
public class ProductApiTests
{
    private readonly WebServerFixture _fixture;

    public ProductApiTests(WebServerFixture fixture)
    {
        _fixture = fixture;
    }

    [Fact]
    public async Task GetProducts_ReturnsProductList()
    {
        var response = await _fixture.Client.GetAsync("/api/products");
        response.EnsureSuccessStatusCode();
        
        var content = await response.Content.ReadAsStringAsync();
        Assert.Contains("products", content);
    }
}
```

---

#### **5. Практические примеры: базы данных, файлы, API-клиенты**

**Пример 1: Работа с файловой системой**
```csharp
public class FileProcessorTests : IDisposable
{
    private readonly string _testDirectory;
    private readonly FileProcessor _processor;

    public FileProcessorTests()
    {
        // Создаем уникальную временную директорию
        _testDirectory = Path.Combine(Path.GetTempPath(), $"FileTests_{Guid.NewGuid()}");
        Directory.CreateDirectory(_testDirectory);
        
        _processor = new FileProcessor();
        
        Console.WriteLine($"Created test directory: {_testDirectory}");
    }

    public void Dispose()
    {
        // Рекурсивно удаляем временную директорию
        try
        {
            if (Directory.Exists(_testDirectory))
            {
                Directory.Delete(_testDirectory, true);
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Warning: Could not delete test directory: {ex.Message}");
        }
    }

    [Fact]
    public void ProcessFile_ValidFile_CreatesOutput()
    {
        var inputFile = Path.Combine(_testDirectory, "input.txt");
        var outputFile = Path.Combine(_testDirectory, "output.txt");
        
        File.WriteAllText(inputFile, "Hello, World!");
        
        _processor.ProcessFile(inputFile, outputFile);
        
        Assert.True(File.Exists(outputFile));
        Assert.Equal("HELLO, WORLD!", File.ReadAllText(outputFile));
    }
}
```

**Пример 2: Тестирование с временными данными**
```csharp
public class DataServiceTests : IDisposable
{
    private readonly List<IDisposable> _cleanupItems = new List<IDisposable>();
    private readonly DataService _service;

    public DataServiceTests()
    {
        _service = new DataService();
    }

    public void Dispose()
    {
        // Очищаем все временные ресурсы в обратном порядке
        foreach (var item in _cleanupItems.AsEnumerable().Reverse())
        {
            try
            {
                item.Dispose();
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Cleanup warning: {ex.Message}");
            }
        }
    }

    private T TrackForCleanup<T>(T item) where T : IDisposable
    {
        _cleanupItems.Add(item);
        return item;
    }

    [Fact]
    public void ProcessTemporaryData_CreatesAndCleansResources()
    {
        var tempFile = TrackForCleanup(new TempFile());
        var tempDatabase = TrackForCleanup(new TempDatabase());
        var tempNetwork = TrackForCleanup(new TempNetworkResource());
        
        var result = _service.ProcessData(tempFile, tempDatabase, tempNetwork);
        
        Assert.True(result.IsSuccess);
        // Все ресурсы будут автоматически очищены в Dispose()
    }
}
```

---

#### **6. Лучшие практики и распространенные ошибки**

**Лучшие практики:**

1. **Используйте конструктор только для инициализации:**
```csharp
// ХОРОШО
public class GoodTestClass : IDisposable
{
    private readonly DatabaseConnection _db;
    
    public GoodTestClass()
    {
        _db = new DatabaseConnection(); // Только инициализация
    }
    
    public void Dispose()
    {
        _db.Dispose(); // Только очистка
    }
}

// ПЛОХО: бизнес-логика в конструкторе
public class BadTestClass : IDisposable
{
    public BadTestClass()
    {
        // Тестовые сценарии не должны быть в конструкторе!
        var service = new UserService();
        service.CreateUser("test"); // АНТИПАТТЕРН!
    }
}
```

2. **Гарантируйте очистку в Dispose:**
```csharp
public void Dispose()
{
    try
    {
        _resource1?.Dispose();
        _resource2?.Close();
        if (File.Exists(_tempFile))
            File.Delete(_tempFile);
    }
    catch (Exception ex)
    {
        // Логируем, но не падаем - teardown не должен влиять на результат теста
        Console.WriteLine($"Cleanup warning: {ex.Message}");
    }
}
```

3. **Используйте уникальные идентификаторы для изоляции:**
```csharp
public class IsolatedTests : IDisposable
{
    private readonly string _testId;
    
    public IsolatedTests()
    {
        _testId = Guid.NewGuid().ToString("N");
        // Каждый тест получает уникальный ID
    }
    
    [Fact]
    public void Test1_UsesUniqueData()
    {
        var data = new TestData { Id = $"{_testId}_data1" };
        // Гарантированно уникальные данные
    }
}
```

**Распространенные ошибки:**

1. **Статическое состояние:**
```csharp
// АНТИПАТТЕРН!
public class StaticStateTests
{
    private static int _counter = 0; // Тесты будут влиять друг на друга!
    
    [Fact]
    public void Test1() { _counter++; }
    
    [Fact] 
    public void Test2() { _counter++; } // Результат зависит от Test1!
}
```

2. **Неидимпотентные тесты:**
```csharp
// ПЛОХО: тест оставляет данные
[Fact]
public void CreateUser_LeavesDataInDatabase()
{
    var service = new UserService();
    service.CreateUser("test_user"); // Пользователь остается в БД!
    
    // Следующий запуск упадет с "user already exists"
}

// ХОРОШО: тест очищает за собой
[Fact]
public void CreateUser_CleansAfterTest()
{
    var service = new UserService();
    var userName = $"test_user_{Guid.NewGuid()}"; // Уникальный
    
    try
    {
        service.CreateUser(userName);
        Assert.True(service.UserExists(userName));
    }
    finally
    {
        service.DeleteUser(userName); // Очистка
    }
}
```

---

### **Резюме**

1. **Setup и TearDown** в xUnit реализуются через **конструктор и IDisposable**
2. **Каждый тест изолирован** - новый экземпляр класса для каждого теста
3. **IClassFixture<T>** для дорогих ресурсов в рамках одного класса
4. **ICollectionFixture<T>** для ресурсов, разделяемых между классами
5. **Гарантируйте очистку** ресурсов в Dispose для предотвращения утечек
6. **Избегайте статического состояния** для сохранения изоляции тестов

---

### **Контрольные вопросы**

1. **Чем подход xUnit к Setup/TearDown отличается от NUnit/MSTest?**
2. **Сколько раз выполнится конструктор тестового класса с 3 тестовыми методами?**
3. **Когда следует использовать IClassFixture<T> вместо конструктора/Dispose?**
4. **Как обеспечить изоляцию тестов, работающих с базой данных?**
5. **Что произойдет, если исключение в Dispose выбросит исключение?**
6. **Как организовать общий ресурс для нескольких тестовых классов?**
7. **Почему статические поля в тестовых классах считаются антипаттерном?**
8. **Как правильно обрабатывать ошибки в методе Dispose?**