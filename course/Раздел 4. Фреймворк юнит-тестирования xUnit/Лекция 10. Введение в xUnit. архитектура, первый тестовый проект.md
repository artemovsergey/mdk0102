# Лекция 10. Введение в xUnit. Архитектура, первый тестовый проект

**Цель:** Познакомить с философией и архитектурой фреймворка xUnit.net, научиться создавать и структурировать тестовые проекты, понимать основные концепции модульного тестирования.

---

### **План лекции**

1.  **Что такое xUnit и его философия?**
2.  **Архитектура xUnit: сравниваем с NUnit и MSTest**
3.  **Создание тестового проекта xUnit**
4.  **Структура теста: факты, теории и утверждения**
5.  **Жизненный цикл теста: фикстуры и контекст выполнения**
6.  **Практика: пишем наши первые осмысленные тесты**

---

### **Подробное рассмотрение каждого пункта плана**

#### **1. Что такое xUnit и его философия?**

**Подробное объяснение:**

xUnit.net — это свободный, ориентированный на сообщество фреймворк для тестирования .NET приложений, созданный одним из оригинальных авторов NUnit. Его философия строится на нескольких ключевых принципах:

*   **Простота и чистота:** xUnit стремится быть минималистичным и убрать лишнее. Каждый атрибут и метод имеют четкое назначение.
*   **Расширяемость:** Архитектура позволяет легко создавать собственные атрибуты, плагины и расширения.
*   **Изоляция тестов:** По умолчанию xUnit создает новый экземпляр тестового класса для каждого тестового метода. Это помогает избежать случайных зависимостей между тестами.

**Почему xUnit важен для тестировщика?**

*   **Стандарт де-факто:** Для новых проектов на .NET Core/.NET 5+ xUnit часто является фреймворком выбора. Его используют многие open-source проекты и крупные компании.
*   **Четкая семантика:** Разделение на `Fact` и `Theory` интуитивно понятно и помогает структурировать тесты.
*   **Гибкость:** Возможность создавать кастомные атрибуты и принцип "независимости по умолчанию" делает его надежным инструментом для построения больших тестовых наборов.

**Пример эволюции:**
Представьте, что NUnit — это швейцарский нож со множеством функций, а xUnit — это современный, эргономичный нож шеф-повара, где каждая деталь продумана для эффективной работы.

---

#### **2. Архитектура xUnit: сравниваем с NUnit и MSTest**

**Подробное объяснение:**

Понимание архитектурных различий помогает принять осознанное решение о выборе фреймворка и миграции между ними.

| Аспект | xUnit | NUnit | MSTest |
|--------|-------|-------|--------|
| **Атрибут теста** | `[Fact]`, `[Theory]` | `[Test]` | `[TestMethod]` |
| **Настройка перед тестом** | Конструктор класса + `public void Setup()` (по соглашению) | `[SetUp]` | `[TestInitialize]` |
| **Фикстура (SetUp/TearDown)** | `IClassFixture<T>`, `ICollectionFixture<T>` | `[SetUp]`, `[TearDown]`, `[OneTimeSetUp]` | `[TestInitialize]`, `[TestCleanup]`, `[ClassInitialize]` |
| **Запуск одного экземпляра класса на все тесты** | ❌ По умолчанию **НЕТ** (новый экземпляр на каждый тест) | ✅ По умолчанию **ДА** | ✅ По умолчанию **ДА** |
| **Дан-тесты (Data-Driven Tests)** | `[Theory]` + `[InlineData]`, `[MemberData]`, `[ClassData]` | `[TestCase]`, `[TestCaseSource]` | `[DataSource]`, `[DynamicData]` |

**Ключевое архитектурное отличие:**

*   **xUnit:** Создает **новый экземпляр тестового класса для каждого тестового метода**. Это гарантирует изоляцию. Если вам нужно разделить состояние между тестами, вы должны явно использовать фикстуры (`IClassFixture<T>`).
*   **NUnit/MSTest:** Создает **один экземпляр тестового класса и переиспользует его для всех тестовых методов**. Это может привести к случайному совместному использованию состояния и "хрупким" тестам.

**Пример проблемы, которую решает xUnit:**
```csharp
// Проблемный код в NUnit/MSTest (если не быть осторожным)
public class BadTestExample
{
    private int _counter = 0; // Общее состояние

    [Test]
    public void Test1()
    {
        _counter++;
        Assert.AreEqual(1, _counter); // Пройдет
    }

    [Test]
    public void Test2()
    {
        _counter++;
        Assert.AreEqual(1, _counter); // УПАДЕТ! Потому что _counter уже = 1 от Test1
    }
}
```
В xUnit такой проблемы не возникнет, так как для `Test1` и `Test2` будут созданы разные экземпляры класса `BadTestExample`.

---

#### **3. Создание тестового проекта xUnit**

**Подробное объяснение:**

Давайте создадим проект шаг за шагом.

**Способ 1: Через Visual Studio**
1.  Файл -> Создать -> Проект.
2.  В поиске введите "xUnit" и выберите "**xUnit Test Project**".
3.  Укажите имя проекта, например, `Calculator.Tests`.
4.  Убедитесь, что в качестве Target Framework выбран `.NET 8.0` (или актуальная LTS-версия).

**Способ 2: Через .NET CLI (Командную строку)**
```bash
dotnet new xunit -n Calculator.Tests
cd Calculator.Tests
```
Эта команда создаст новую папку `Calculator.Tests` с готовым к работе тестовым проектом.

**Структура созданного проекта:**
*   `Calculator.Tests.csproj` — файл проекта.
*   `UnitTest1.cs` — пример тестового класса (его можно переименовать или удалить).

**Взгляд тестировщика на `csproj`:**
Откройте файл проекта. Вы увидите примерно следующее:
```xml
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net8.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
    <IsPackable>false</IsPackable>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.NET.Test.Sdk" Version="17.8.0" />
    <PackageReference Include="xunit" Version="2.6.6" />
    <PackageReference Include="xunit.runner.visualstudio" Version="2.5.5" />
  </ItemGroup>

</Project>
```
*   `Microsoft.NET.Test.Sdk` — общий SDK для запуска тестов.
*   `xunit` — ядро фреймворка.
*   `xunit.runner.visualstudio` — адаптер для интеграции с Visual Studio (чтобы тесты отображались в Test Explorer).

---

#### **4. Структура теста: факты, теории и утверждения**

**Подробное объяснение:**

xUnit вводит две фундаментальные концепции тестов.

**`[Fact]` — Тест-факт**
*   Это тест, который всегда выполняется одинаково.
*   Он не принимает никаких параметров.
*   Используется для проверки конкретного, единственного сценария.

**Пример `[Fact]`:**
```csharp
public class CalculatorFactTests
{
    [Fact]
    public void Add_TwoNumbers_ReturnsSum()
    {
        // Arrange (Подготовка)
        var calculator = new Calculator(); // Предположим, что этот класс существует
        int a = 5;
        int b = 3;
        int expected = 8;

        // Act (Действие)
        int actual = calculator.Add(a, b);

        // Assert (Проверка/Утверждение)
        Assert.Equal(expected, actual);
    }
}
```

**`[Theory]` — Тест-теория**
*   Это тест, который выполняется многократно для разных наборов входных данных.
*   Он принимает параметры.
*   Данные для параметров передаются через атрибуты: `[InlineData]`, `[MemberData]`, `[ClassData]`.

**Пример `[Theory]` с `[InlineData]`:**
```csharp
public class CalculatorTheoryTests
{
    [Theory]
    [InlineData(1, 1, 2)]    // Набор данных #1
    [InlineData(2, 3, 5)]    // Набор данных #2
    [InlineData(0, 0, 0)]    // Набор данных #3
    [InlineData(-5, 5, 0)]   // Набор данных #4 (пограничный случай)
    public void Add_TwoNumbers_ReturnsSum(int a, int b, int expected)
    {
        // Arrange
        var calculator = new Calculator();

        // Act
        int actual = calculator.Add(a, b);

        // Assert
        Assert.Equal(expected, actual);
    }
}
```
В Test Explorer вы увидите **4 отдельных теста**, по одному на каждый `[InlineData]`. Это мощный инструмент для покрытия одного метода несколькими наборами данных.

**Класс `Assert`:**
Это ваш главный инструмент для проверок.
*   `Assert.Equal(expected, actual)` — проверка на равенство.
*   `Assert.True(condition)` / `Assert.False(condition)` — проверка булевых условий.
*   `Assert.Null(object)` / `Assert.NotNull(object)` — проверки на null.
*   `Assert.Throws<ExceptionType>(() => code)` — проверка, что код бросает конкретное исключение.

---

#### **5. Жизненный цикл теста: фикстуры и контекст выполнения**

**Подробное объяснение:**

xUnit предоставляет гибкие способы управления состоянием и ресурсами.

**1. Конструктор и `IDisposable` (Аналог `[SetUp]`/`[TearDown]`)**
Поскольку xUnit создает новый экземпляр класса для каждого теста, код в конструкторе выполняется перед каждым тестом, а код в `Dispose()` — после.

```csharp
public class LifecycleTests : IDisposable
{
    private readonly DatabaseConnection _dbConnection; // Дорогой ресурс

    public LifecycleTests()
    {
        // Setup: выполняется ПЕРЕД КАЖДЫМ тестом
        _dbConnection = new DatabaseConnection("connection_string");
        _dbConnection.Open();
    }

    public void Dispose()
    {
        // Teardown: выполняется ПОСЛЕ КАЖДОГО теста
        _dbConnection?.Close();
        _dbConnection?.Dispose();
    }

    [Fact]
    public void Test1()
    {
        // Используем _dbConnection здесь
    }
}
```

**2. Фикстуры уровня класса (`IClassFixture<T>`)**
Используется, когда нужно разделить **один экземпляр дорогостоящего ресурса** между всеми тестами в классе.

```csharp
// 1. Создаем класс фикстуры
public class DatabaseFixture : IDisposable
{
    public DatabaseConnection Db { get; private set; }

    public DatabaseFixture()
    {
        Db = new DatabaseConnection("connection_string");
        Db.Open();
    }

    public void Dispose()
    {
        Db?.Close();
        Db?.Dispose();
    }
}

// 2. Сообщаем тестовому классу использовать фикстуру
public class DatabaseTests : IClassFixture<DatabaseFixture>
{
    private readonly DatabaseFixture _fixture;

    // Фикстура инжектируется через конструктор
    public DatabaseTests(DatabaseFixture fixture)
    {
        _fixture = fixture;
    }

    [Fact]
    public void Test1()
    {
        // Все тесты в этом классе используют один и тот же _fixture.Db
        var data = _fixture.Db.GetData();
        Assert.NotNull(data);
    }
}
```

---

#### **6. Практика: пишем наши первые осмысленные тесты**

**Задача:** Протестировать простой класс `StringValidator`.

**Код под тест (`StringValidator.cs`):**
```csharp
public static class StringValidator
{
    public static bool IsPalindrome(string str)
    {
        if (string.IsNullOrEmpty(str)) return false;
        
        var cleaned = new string(str.Where(char.IsLetterOrDigit).ToArray()).ToLower();
        return cleaned.SequenceEqual(cleaned.Reverse());
    }

    public static bool IsValidEmail(string email)
    {
        if (string.IsNullOrEmpty(email)) return false;
        try
        {
            var addr = new System.Net.Mail.MailAddress(email);
            return addr.Address == email;
        }
        catch
        {
            return false;
        }
    }
}
```

**Тестовый класс (`StringValidatorTests.cs`):**
```csharp
public class StringValidatorTests
{
    // --- Tests for IsPalindrome ---
    
    [Theory]
    [InlineData("A man a plan a canal Panama", true)]  // Сложный палиндром
    [InlineData("racecar", true)]                       // Простой палиндром
    [InlineData("hello", false)]                        // Не палиндром
    [InlineData("", false)]                             // Граничный случай: пустая строка
    [InlineData(null, false)]                           // Граничный случай: null
    [InlineData("a", true)]                             // Граничный случай: один символ
    public void IsPalindrome_VariousInputs_ReturnsExpectedResult(string input, bool expected)
    {
        // Act & Assert
        Assert.Equal(expected, StringValidator.IsPalindrome(input));
    }

    // --- Tests for IsValidEmail ---
    
    [Theory]
    [InlineData("test@example.com", true)]
    [InlineData("invalid-email", false)]
    [InlineData("", false)]
    [InlineData(null, false)]
    [InlineData("user@domain.co.uk", true)] // Сложный домен
    public void IsValidEmail_VariousInputs_ReturnsExpectedResult(string email, bool expected)
    {
        // Act & Assert
        Assert.Equal(expected, StringValidator.IsValidEmail(email));
    }

    [Fact]
    public void IsValidEmail_WithNull_ReturnsFalse()
    {
        // Этот тест избыточен после [InlineData(null, false)], но показан как пример [Fact]
        // Act
        bool result = StringValidator.IsValidEmail(null);
        
        // Assert
        Assert.False(result);
    }
}
```

**Запуск и анализ:**
1.  Постройте решение.
2.  Откройте **Test Explorer**.
3.  Вы увидите все тесты, сгруппированные по классам. Запустите их.
4.  Обратите внимание, как `[Theory]` разбивается на множество отдельных тестовых случаев.

---

### **Резюме**

1.  **xUnit** — это современный, гибкий фреймворк для тестирования, построенный на принципах простоты и изоляции.
2.  **Ключевые концепции:** `[Fact]` для одиночных сценариев, `[Theory]` для параметризованных тестов.
3.  **Архитектура:** xUnit создает новый экземпляр тестового класса для каждого метода, обеспечивая изоляцию по умолчанию.
4.  **Фикстуры:** `IClassFixture<T>` позволяет разделять дорогостоящие ресурсы между тестами в рамках одного класса.
5.  **Для тестировщика:** xUnit идеально подходит для создания стабильных, поддерживаемых и хорошо структурированных наборов автотестов.

---

### **Контрольные вопросы**

1.  В чем главное философское отличие xUnit от NUnit?
2.  Объясните разницу между атрибутами `[Fact]` и `[Theory]`. В каком случае вы будете использовать каждый из них?
3.  Как в xUnit реализована настройка окружения перед каждым тестом и очистка после?
4.  Что такое `IClassFixture<T>` и для решения какой проблемы он предназначен?
5.  Сколько тестов будет отображено в Test Explorer для метода, помеченного `[Theory]` с тремя атрибутами `[InlineData]`?
6.  Какой метод из класса `Assert` вы будете использовать, чтобы проверить, что метод бросает исключение `ArgumentNullException`?
7.  *Практическая задача:* Представьте, что у вас есть метод `Divide(int a, int b)`. Напишите тест с использованием `[Theory]`, который проверит корректное деление и обработку деления на ноль (с помощью `Assert.Throws`).