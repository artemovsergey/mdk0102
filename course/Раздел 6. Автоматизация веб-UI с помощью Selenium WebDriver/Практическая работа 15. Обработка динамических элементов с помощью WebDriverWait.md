# Практическая работа 15. Обработка динамических элементов с помощью WebDriverWait

---

## Цель работы

* Научиться использовать ожидания элементов при автоматизации тестов на Selenium WebDriver.
* Освоить **Explicit Wait** и **Fluent Wait** для стабилизации тестов с динамически загружающимися элементами.
* Научиться проверять видимость, кликабельность и наличие текста на элементах.

---

## Теоретическая часть

### Проблема динамических элементов

Веб-страницы часто используют AJAX, JavaScript или динамическую загрузку данных. Если WebDriver сразу попытается взаимодействовать с элементом, который ещё не загрузился, тест падает с ошибкой:

```
NoSuchElementException
ElementNotInteractableException
```

### Решение

Использовать **ожидания (Waits)**:

1. **Implicit Wait** – глобальное ожидание для поиска всех элементов

   ```csharp
   driver.Manage().Timeouts().ImplicitWait = TimeSpan.FromSeconds(10);
   ```

   *Недостаток:* не подходит для условий кликабельности или появления текста.

2. **Explicit Wait (WebDriverWait)** – локальное ожидание с условием

   ```csharp
   WebDriverWait wait = new WebDriverWait(driver, TimeSpan.FromSeconds(10));
   IWebElement element = wait.Until(ExpectedConditions.ElementToBeClickable(By.Id("loginBtn")));
   ```

3. **Fluent Wait** – расширенная версия Explicit Wait с частотой опроса и игнорированием исключений

   ```csharp
   DefaultWait<IWebDriver> fluentWait = new DefaultWait<IWebDriver>(driver);
   fluentWait.Timeout = TimeSpan.FromSeconds(15);
   fluentWait.PollingInterval = TimeSpan.FromSeconds(1);
   fluentWait.IgnoreExceptionTypes(typeof(NoSuchElementException));
   IWebElement element = fluentWait.Until(d => d.FindElement(By.Id("dynamicElement")));
   ```

**Типовые условия для Explicit Wait:**

* `ElementIsVisible` – элемент видим
* `ElementToBeClickable` – элемент доступен для клика
* `TextToBePresentInElement` – текст появился
* `PresenceOfAllElementsLocatedBy` – элементы присутствуют в DOM

---

## Ход работы

### Шаг 1. Подготовка проекта

1. Создать **NUnit Test Project** на C#.
2. Установить через NuGet:

   * `Selenium.WebDriver`
   * `Selenium.WebDriver.ChromeDriver`
   * `Selenium.Support`

---

### Шаг 2. Настройка WebDriver

```csharp
using NUnit.Framework;
using OpenQA.Selenium;
using OpenQA.Selenium.Chrome;
using OpenQA.Selenium.Support.UI;
using SeleniumExtras.WaitHelpers;

namespace DynamicElementsTests
{
    [TestFixture]
    public class WaitTests
    {
        private IWebDriver _driver;
        private WebDriverWait _wait;

        [SetUp]
        public void Setup()
        {
            _driver = new ChromeDriver();
            _driver.Manage().Window.Maximize();
            _driver.Navigate().GoToUrl("https://example.com/dynamic");
            _wait = new WebDriverWait(_driver, TimeSpan.FromSeconds(10));
        }

        [TearDown]
        public void TearDown()
        {
            _driver.Quit();
        }
    }
}
```

---

### Шаг 3. Пример использования Explicit Wait

```csharp
[Test]
public void WaitForElementToBeClickable()
{
    // Ждём, пока кнопка станет кликабельной
    IWebElement startButton = _wait.Until(ExpectedConditions.ElementToBeClickable(By.Id("startBtn")));
    startButton.Click();

    // Ждём появления текста после клика
    IWebElement resultText = _wait.Until(ExpectedConditions.ElementIsVisible(By.Id("result")));
    Assert.AreEqual("Completed", resultText.Text, "Текст не совпадает");
}
```

---

### Шаг 4. Пример использования Fluent Wait

```csharp
[Test]
public void FluentWaitExample()
{
    var fluentWait = new DefaultWait<IWebDriver>(_driver)
    {
        Timeout = TimeSpan.FromSeconds(15),
        PollingInterval = TimeSpan.FromSeconds(1)
    };
    fluentWait.IgnoreExceptionTypes(typeof(NoSuchElementException));

    IWebElement dynamicElement = fluentWait.Until(d => d.FindElement(By.Id("dynamicElement")));
    dynamicElement.Click();

    IWebElement message = fluentWait.Until(d => d.FindElement(By.Id("status")));
    Assert.IsTrue(message.Displayed, "Сообщение не отображается");
}
```

---

## Практический пример

**Сценарий:**

1. Открыть страницу с динамически загружающимся элементом.
2. Дождаться появления кнопки «Start».
3. Кликнуть кнопку.
4. Проверить появление текста «Completed».

---

## Варианты заданий (по номеру в журнале)

1. Использовать Explicit Wait для кнопки «Start»
2. Дождаться появления текста «Completed» после клика
3. Дождаться появления поля ввода и ввести текст
4. Дождаться, пока элемент станет кликабельным
5. Использовать Fluent Wait для динамически загружаемого элемента
6. Проверить видимость сообщения об ошибке после задержки
7. Ждать появления ссылки «Подробнее» и кликнуть
8. Ждать появления изображения на странице
9. Проверить динамическое появление списка элементов
10. Дождаться изменения текста на кнопке
11. Дождаться появления чекбокса и отметить его
12. Проверить наличие всплывающего сообщения
13. Дождаться появления выпадающего списка и выбрать значение
14. Использовать Fluent Wait для элемента, который появляется после AJAX-запроса
15. Комбинированный тест: дождаться нескольких элементов и выполнить последовательные действия

---

## Критерии оценки

| Оценка | Критерии                                                                                              |
| ------ | ----------------------------------------------------------------------------------------------------- |
| 2      | Тест создается, но не использует ожидания; элемент не найден стабильно                                |
| 3      | Используется один тип ожидания (Explicit или Fluent) для одного элемента                              |
| 4      | Используются ожидания для всех динамических элементов; тесты проходят стабильно                       |
| 5      | Используются Explicit и Fluent Wait; тесты структурированы, есть Page Object Model, скриншоты, readme |

---

## Контрольные вопросы

1. Почему необходимо использовать ожидания для динамических элементов?
2. Чем отличается Implicit Wait от Explicit Wait?
3. Что такое Fluent Wait и когда его применяют?
4. Какие условия можно использовать с Explicit Wait?
5. Как обработать исключение `NoSuchElementException` при динамических элементах?
6. Как проверить текст элемента после клика по кнопке?
7. Как структурировать тесты для динамических элементов в проекте?

---

## Структура репозитория

```
DynamicWaitTests/
│
├─ Drivers/           # инициализация WebDriver
├─ Pages/             # Page классы (опционально)
├─ Tests/             # Тестовые классы с ожиданиями
├─ images/            # Скриншоты работы тестов
└─ readme.md          # Описание работы, вариант, текст задания
```

### Пример `readme.md`

````markdown
# Практическая работа №15
## Тема: Обработка динамических элементов с помощью WebDriverWait
### Вариант: 4

**Задание:** Дождаться появления кнопки «Start», кликнуть её и проверить появление текста «Completed».

**Пример кода:**
```csharp
WebDriverWait wait = new WebDriverWait(driver, TimeSpan.FromSeconds(10));
IWebElement startButton = wait.Until(ExpectedConditions.ElementToBeClickable(By.Id("startBtn")));
startButton.Click();

IWebElement resultText = wait.Until(ExpectedConditions.ElementIsVisible(By.Id("result")));
Assert.AreEqual("Completed", resultText.Text);
````

```
